# coding: utf-8

"""
    PowerBot - Webservice for algotrading

    # TERMS AND CONDITIONS The PowerBot system provides B2B services for trading at intraday power markets. By using the PowerBot service, each user agrees to the terms and conditions of this licence: 1. The user confirms that they are familiar with the exchanges trading system and all relevant rules, is professionally qualified and in possession of a trading license for the relevant exchange. 2. The user will comply with the exchanges market rules (e.g. [EPEX Spot Market Rules](https://www.epexspot.com/en/downloads#rules-fees-processes) or [Nord Pool Market Rules](https://www.nordpoolgroup.com/trading/Rules-and-regulations/)) and will not endanger the exchange system at any time with heavy load from trading algorithms or by other use. 3. The user is aware of limits imposed by the exchange. 4. The user is solely liable for actions resulting from the use of PowerBot.   # INTRODUCTION PowerBot is a web-based software service enabling algorithmic trading on intraday power exchanges such as EPEX, Nord Pool, HUPX, BSP Southpool, TGE, OPCOM or ETPA. The service is straightforward to integrate in an existing software environment and provides a variety of programming interfaces for development of individual trading algorithms and software tools. Besides enabling fully automated intraday trading, it can be used to create tools for human traders providing relevant information and trading opportunities or can be integrated in existing software tools. For further details see https://www.powerbot-trading.com  ## Knowledge Base In addition to this API guide, please find the documentation at https://docs.powerbot-trading.com - the password will be provided by the PowerBot team. If not, please reach out to us at support@powerbot-trading.com  ## Endpoints The PowerBot service is available at the following REST endpoints:  | Instance      | Base URL for REST Endpoints                                      | |---------------|------------------------------------------------------------------| | EPEX          | https://staging.powerbot-trading.com/playground/epex/v2/api      | | Nord Pool     | https://staging.powerbot-trading.com/playground/nordpool/v2/api  | | HUPX          | https://staging.powerbot-trading.com/playground/hupx/v2/api      | | BSP Southpool | https://staging.powerbot-trading.com/playground/southpool/v2/api | | TGE           | https://staging.powerbot-trading.com/playground/tge/v2/api       | | IBEX          | https://staging.powerbot-trading.com/playground/ibex/v2/api      | | CROPEX        | https://staging.powerbot-trading.com/playground/cropex/v2/api    | | OPCOM         | https://staging.powerbot-trading.com/playground/opcom/v2/api     | | ETPA          | https://staging.powerbot-trading.com/playground/etpa/v2/api      | | BRM           | https://staging.powerbot-trading.com/playground/brm/v2/api       |  Access to endpoints is secured via an API Key, which needs to be passed as an \"api_key\" header in each request.   Notes on API Keys:  * API keys are specific to Test, Staging or Production.  * API keys are generated by the system administrator and need to be requested.  ## How to generate API clients (libraries) This OpenAPI specification can be used to generate API clients (programming libraries) for a wide range of programming languages using tools like [OpenAPI Generator](https://openapi-generator.tech/). A detailed guide can be found in the [knowledge base](https://docs.powerbot-trading.com/articles/getting-started/generating-clients/).  ## PowerBot Python client For Python, a ready-made client is also available on PyPI and can be downloaded locally via:  ```shell   pip install powerbot-client ```  ## Errors The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be in JSON format as follows:  ``` {   \"message\": \"... an error message ...\" } ```  ## Paging The API uses offset and limit parameters for paged operations. An X-Total-Count header is added to responses to indicate the total number of items in a paged response.  ## Cross-Origin Resource Sharing This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with  [W3C spec](https://www.w3.org/TR/cors/). This allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site.  ## API Rate Limiting The API limits the number of concurrent calls to 50 - when that limit is reached, the client will receive 503 http status codes (service unavailable) with the following text:  ``` {   \"message\": \"API rate limit exceeded\" } ``` Clients should ensure that they stay within the limit for concurrent API calls.    ## Additional code samples Additional information and code samples demonstrating the use of the API can be found at in our [knowledge base](https://docs.powerbot-trading.com/docs/programmatic-access/)

    The version of the OpenAPI document: 2.16.1
    Contact: office@powerbot-trading.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import List, Optional, Union
from typing_extensions import Annotated
from powerbot_client.models.bulk_contract_statistics import BulkContractStatistics
from powerbot_client.models.contract_history_item import ContractHistoryItem
from powerbot_client.models.contract_item import ContractItem
from powerbot_client.models.contract_statistics import ContractStatistics
from powerbot_client.models.contract_type import ContractType
from powerbot_client.models.order_book_bulk_statistics import OrderBookBulkStatistics
from powerbot_client.models.order_books import OrderBooks
from powerbot_client.models.orders import Orders
from powerbot_client.models.public_trade import PublicTrade
from powerbot_client.models.risk_settings_and_portfolio_information import RiskSettingsAndPortfolioInformation
from powerbot_client.models.signal import Signal

from powerbot_client.api_client import ApiClient, RequestSerialized
from powerbot_client.api_response import ApiResponse
from powerbot_client.rest import RESTResponseType


class ContractApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def calculate_bulk_statistics(
        self,
        contract_duration_minutes: Annotated[StrictInt, Field(description="the duration of the contracts to calculate statistics for")],
        delivery_area: List[StrictStr],
        delivery_from: datetime,
        delivery_to: datetime,
        execution_from_offset_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="only consider trades that happened after or at (delivery start - n minutes)")] = None,
        execution_to_offset_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="only consider trades that happened before (delivery start - n minutes)")] = None,
        limit_to_last_mw: Optional[Union[StrictFloat, StrictInt]] = None,
        include_historic_data: Annotated[Optional[StrictBool], Field(description="If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkContractStatistics:
        """Get contract statistics in bulk

        Calculates the average price and volume of public trades executed for a given delivery interval for reference price and index calculation. Allows you to filter for public trades executed within a certain time period to restrict the calculation to a given amount of last traded quantity. Per default, only active or recently active contracts will be included in the calculation. Historic contracts matching the given delivery period can be included with setting the respective toggle. Please note that delivery_start and delivery_end have to be within 24 hours. Cross border trades are taken into account if either the buy or sell leg of the trade is in the specified delivery area(s). The quantity of only one of those trades will be taken into account, if a trade matches.

        :param contract_duration_minutes: the duration of the contracts to calculate statistics for (required)
        :type contract_duration_minutes: int
        :param delivery_area: (required)
        :type delivery_area: List[str]
        :param delivery_from: (required)
        :type delivery_from: datetime
        :param delivery_to: (required)
        :type delivery_to: datetime
        :param execution_from_offset_minutes: only consider trades that happened after or at (delivery start - n minutes)
        :type execution_from_offset_minutes: int
        :param execution_to_offset_minutes: only consider trades that happened before (delivery start - n minutes)
        :type execution_to_offset_minutes: int
        :param limit_to_last_mw:
        :type limit_to_last_mw: float
        :param include_historic_data: If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.
        :type include_historic_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._calculate_bulk_statistics_serialize(
            contract_duration_minutes=contract_duration_minutes,
            delivery_area=delivery_area,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            execution_from_offset_minutes=execution_from_offset_minutes,
            execution_to_offset_minutes=execution_to_offset_minutes,
            limit_to_last_mw=limit_to_last_mw,
            include_historic_data=include_historic_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkContractStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def calculate_bulk_statistics_with_http_info(
        self,
        contract_duration_minutes: Annotated[StrictInt, Field(description="the duration of the contracts to calculate statistics for")],
        delivery_area: List[StrictStr],
        delivery_from: datetime,
        delivery_to: datetime,
        execution_from_offset_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="only consider trades that happened after or at (delivery start - n minutes)")] = None,
        execution_to_offset_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="only consider trades that happened before (delivery start - n minutes)")] = None,
        limit_to_last_mw: Optional[Union[StrictFloat, StrictInt]] = None,
        include_historic_data: Annotated[Optional[StrictBool], Field(description="If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkContractStatistics]:
        """Get contract statistics in bulk

        Calculates the average price and volume of public trades executed for a given delivery interval for reference price and index calculation. Allows you to filter for public trades executed within a certain time period to restrict the calculation to a given amount of last traded quantity. Per default, only active or recently active contracts will be included in the calculation. Historic contracts matching the given delivery period can be included with setting the respective toggle. Please note that delivery_start and delivery_end have to be within 24 hours. Cross border trades are taken into account if either the buy or sell leg of the trade is in the specified delivery area(s). The quantity of only one of those trades will be taken into account, if a trade matches.

        :param contract_duration_minutes: the duration of the contracts to calculate statistics for (required)
        :type contract_duration_minutes: int
        :param delivery_area: (required)
        :type delivery_area: List[str]
        :param delivery_from: (required)
        :type delivery_from: datetime
        :param delivery_to: (required)
        :type delivery_to: datetime
        :param execution_from_offset_minutes: only consider trades that happened after or at (delivery start - n minutes)
        :type execution_from_offset_minutes: int
        :param execution_to_offset_minutes: only consider trades that happened before (delivery start - n minutes)
        :type execution_to_offset_minutes: int
        :param limit_to_last_mw:
        :type limit_to_last_mw: float
        :param include_historic_data: If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.
        :type include_historic_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._calculate_bulk_statistics_serialize(
            contract_duration_minutes=contract_duration_minutes,
            delivery_area=delivery_area,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            execution_from_offset_minutes=execution_from_offset_minutes,
            execution_to_offset_minutes=execution_to_offset_minutes,
            limit_to_last_mw=limit_to_last_mw,
            include_historic_data=include_historic_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkContractStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def calculate_bulk_statistics_without_preload_content(
        self,
        contract_duration_minutes: Annotated[StrictInt, Field(description="the duration of the contracts to calculate statistics for")],
        delivery_area: List[StrictStr],
        delivery_from: datetime,
        delivery_to: datetime,
        execution_from_offset_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="only consider trades that happened after or at (delivery start - n minutes)")] = None,
        execution_to_offset_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="only consider trades that happened before (delivery start - n minutes)")] = None,
        limit_to_last_mw: Optional[Union[StrictFloat, StrictInt]] = None,
        include_historic_data: Annotated[Optional[StrictBool], Field(description="If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get contract statistics in bulk

        Calculates the average price and volume of public trades executed for a given delivery interval for reference price and index calculation. Allows you to filter for public trades executed within a certain time period to restrict the calculation to a given amount of last traded quantity. Per default, only active or recently active contracts will be included in the calculation. Historic contracts matching the given delivery period can be included with setting the respective toggle. Please note that delivery_start and delivery_end have to be within 24 hours. Cross border trades are taken into account if either the buy or sell leg of the trade is in the specified delivery area(s). The quantity of only one of those trades will be taken into account, if a trade matches.

        :param contract_duration_minutes: the duration of the contracts to calculate statistics for (required)
        :type contract_duration_minutes: int
        :param delivery_area: (required)
        :type delivery_area: List[str]
        :param delivery_from: (required)
        :type delivery_from: datetime
        :param delivery_to: (required)
        :type delivery_to: datetime
        :param execution_from_offset_minutes: only consider trades that happened after or at (delivery start - n minutes)
        :type execution_from_offset_minutes: int
        :param execution_to_offset_minutes: only consider trades that happened before (delivery start - n minutes)
        :type execution_to_offset_minutes: int
        :param limit_to_last_mw:
        :type limit_to_last_mw: float
        :param include_historic_data: If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.
        :type include_historic_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._calculate_bulk_statistics_serialize(
            contract_duration_minutes=contract_duration_minutes,
            delivery_area=delivery_area,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            execution_from_offset_minutes=execution_from_offset_minutes,
            execution_to_offset_minutes=execution_to_offset_minutes,
            limit_to_last_mw=limit_to_last_mw,
            include_historic_data=include_historic_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkContractStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _calculate_bulk_statistics_serialize(
        self,
        contract_duration_minutes,
        delivery_area,
        delivery_from,
        delivery_to,
        execution_from_offset_minutes,
        execution_to_offset_minutes,
        limit_to_last_mw,
        include_historic_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'delivery_area': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if contract_duration_minutes is not None:
            
            _query_params.append(('contract_duration_minutes', contract_duration_minutes))
            
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        if execution_from_offset_minutes is not None:
            
            _query_params.append(('execution_from_offset_minutes', execution_from_offset_minutes))
            
        if execution_to_offset_minutes is not None:
            
            _query_params.append(('execution_to_offset_minutes', execution_to_offset_minutes))
            
        if limit_to_last_mw is not None:
            
            _query_params.append(('limit_to_last_mw', limit_to_last_mw))
            
        if include_historic_data is not None:
            
            _query_params.append(('includeHistoricData', include_historic_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contracts/bulkstatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def calculate_statistics(
        self,
        delivery_area: List[StrictStr],
        delivery_start: datetime,
        delivery_end: datetime,
        execution_from: Optional[datetime] = None,
        execution_to: Optional[datetime] = None,
        limit_to_last_mw: Optional[Union[StrictFloat, StrictInt]] = None,
        include_historic_data: Annotated[Optional[StrictBool], Field(description="If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ContractStatistics:
        """Get contract statistics

        Calculates the average price and volume of public trades executed for a given delivery interval for reference price and index calculation. Allows you to filter for public trades executed within a certain time period to restrict the calculation to a given amount of last traded quantity. Per default, only active or recently active contracts will be included in the calculation. Historic contracts matching the given delivery period can be included with setting the respective toggle. Please note that delivery_start and delivery_end have to be within 24 hours. Cross border trades are taken into account if either the buy or sell leg of the trade is in the specified delivery area(s). The quantity of only one of those trades will be taken into account, if a trades matches.

        :param delivery_area: (required)
        :type delivery_area: List[str]
        :param delivery_start: (required)
        :type delivery_start: datetime
        :param delivery_end: (required)
        :type delivery_end: datetime
        :param execution_from:
        :type execution_from: datetime
        :param execution_to:
        :type execution_to: datetime
        :param limit_to_last_mw:
        :type limit_to_last_mw: float
        :param include_historic_data: If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.
        :type include_historic_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._calculate_statistics_serialize(
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            execution_from=execution_from,
            execution_to=execution_to,
            limit_to_last_mw=limit_to_last_mw,
            include_historic_data=include_historic_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContractStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def calculate_statistics_with_http_info(
        self,
        delivery_area: List[StrictStr],
        delivery_start: datetime,
        delivery_end: datetime,
        execution_from: Optional[datetime] = None,
        execution_to: Optional[datetime] = None,
        limit_to_last_mw: Optional[Union[StrictFloat, StrictInt]] = None,
        include_historic_data: Annotated[Optional[StrictBool], Field(description="If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ContractStatistics]:
        """Get contract statistics

        Calculates the average price and volume of public trades executed for a given delivery interval for reference price and index calculation. Allows you to filter for public trades executed within a certain time period to restrict the calculation to a given amount of last traded quantity. Per default, only active or recently active contracts will be included in the calculation. Historic contracts matching the given delivery period can be included with setting the respective toggle. Please note that delivery_start and delivery_end have to be within 24 hours. Cross border trades are taken into account if either the buy or sell leg of the trade is in the specified delivery area(s). The quantity of only one of those trades will be taken into account, if a trades matches.

        :param delivery_area: (required)
        :type delivery_area: List[str]
        :param delivery_start: (required)
        :type delivery_start: datetime
        :param delivery_end: (required)
        :type delivery_end: datetime
        :param execution_from:
        :type execution_from: datetime
        :param execution_to:
        :type execution_to: datetime
        :param limit_to_last_mw:
        :type limit_to_last_mw: float
        :param include_historic_data: If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.
        :type include_historic_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._calculate_statistics_serialize(
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            execution_from=execution_from,
            execution_to=execution_to,
            limit_to_last_mw=limit_to_last_mw,
            include_historic_data=include_historic_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContractStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def calculate_statistics_without_preload_content(
        self,
        delivery_area: List[StrictStr],
        delivery_start: datetime,
        delivery_end: datetime,
        execution_from: Optional[datetime] = None,
        execution_to: Optional[datetime] = None,
        limit_to_last_mw: Optional[Union[StrictFloat, StrictInt]] = None,
        include_historic_data: Annotated[Optional[StrictBool], Field(description="If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get contract statistics

        Calculates the average price and volume of public trades executed for a given delivery interval for reference price and index calculation. Allows you to filter for public trades executed within a certain time period to restrict the calculation to a given amount of last traded quantity. Per default, only active or recently active contracts will be included in the calculation. Historic contracts matching the given delivery period can be included with setting the respective toggle. Please note that delivery_start and delivery_end have to be within 24 hours. Cross border trades are taken into account if either the buy or sell leg of the trade is in the specified delivery area(s). The quantity of only one of those trades will be taken into account, if a trades matches.

        :param delivery_area: (required)
        :type delivery_area: List[str]
        :param delivery_start: (required)
        :type delivery_start: datetime
        :param delivery_end: (required)
        :type delivery_end: datetime
        :param execution_from:
        :type execution_from: datetime
        :param execution_to:
        :type execution_to: datetime
        :param limit_to_last_mw:
        :type limit_to_last_mw: float
        :param include_historic_data: If this option is enabled, statistics will also be calculated for expired contracts that match the given delivery period.
        :type include_historic_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._calculate_statistics_serialize(
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            execution_from=execution_from,
            execution_to=execution_to,
            limit_to_last_mw=limit_to_last_mw,
            include_historic_data=include_historic_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContractStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _calculate_statistics_serialize(
        self,
        delivery_area,
        delivery_start,
        delivery_end,
        execution_from,
        execution_to,
        limit_to_last_mw,
        include_historic_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'delivery_area': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if delivery_start is not None:
            if isinstance(delivery_start, datetime):
                _query_params.append(
                    (
                        'delivery_start',
                        delivery_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_start', delivery_start))
            
        if delivery_end is not None:
            if isinstance(delivery_end, datetime):
                _query_params.append(
                    (
                        'delivery_end',
                        delivery_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_end', delivery_end))
            
        if execution_from is not None:
            if isinstance(execution_from, datetime):
                _query_params.append(
                    (
                        'execution_from',
                        execution_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('execution_from', execution_from))
            
        if execution_to is not None:
            if isinstance(execution_to, datetime):
                _query_params.append(
                    (
                        'execution_to',
                        execution_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('execution_to', execution_to))
            
        if limit_to_last_mw is not None:
            
            _query_params.append(('limit_to_last_mw', limit_to_last_mw))
            
        if include_historic_data is not None:
            
            _query_params.append(('includeHistoricData', include_historic_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contracts/statistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_contracts(
        self,
        contract_id: Optional[List[StrictStr]] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="Limit the contracts to those with the given delivery start date.")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="Limit the contracts to those with the given delivery end date.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the contracts to those with a delivery start date >= delivery_from.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the contracts to those with a delivery end date <= delivery_to.")] = None,
        delivery_areas: Annotated[Optional[List[StrictStr]], Field(description="Limit the search to contracts that belong to any of the specified delivery areas.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ContractItem]:
        """Find contracts

        This method allows you to find active or historical contracts based on their exact delivery_start and delivery_end time (UTC) and lets you determine their contract_id. Using delivery_from and delivery_to, the contracts can be further limited to a given timespan.

        :param contract_id:
        :type contract_id: List[str]
        :param delivery_start: Limit the contracts to those with the given delivery start date.
        :type delivery_start: datetime
        :param delivery_end: Limit the contracts to those with the given delivery end date.
        :type delivery_end: datetime
        :param delivery_from: Limits the contracts to those with a delivery start date >= delivery_from.
        :type delivery_from: datetime
        :param delivery_to: Limits the contracts to those with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param delivery_areas: Limit the search to contracts that belong to any of the specified delivery areas.
        :type delivery_areas: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_contracts_serialize(
            contract_id=contract_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            delivery_areas=delivery_areas,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ContractItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_contracts_with_http_info(
        self,
        contract_id: Optional[List[StrictStr]] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="Limit the contracts to those with the given delivery start date.")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="Limit the contracts to those with the given delivery end date.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the contracts to those with a delivery start date >= delivery_from.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the contracts to those with a delivery end date <= delivery_to.")] = None,
        delivery_areas: Annotated[Optional[List[StrictStr]], Field(description="Limit the search to contracts that belong to any of the specified delivery areas.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ContractItem]]:
        """Find contracts

        This method allows you to find active or historical contracts based on their exact delivery_start and delivery_end time (UTC) and lets you determine their contract_id. Using delivery_from and delivery_to, the contracts can be further limited to a given timespan.

        :param contract_id:
        :type contract_id: List[str]
        :param delivery_start: Limit the contracts to those with the given delivery start date.
        :type delivery_start: datetime
        :param delivery_end: Limit the contracts to those with the given delivery end date.
        :type delivery_end: datetime
        :param delivery_from: Limits the contracts to those with a delivery start date >= delivery_from.
        :type delivery_from: datetime
        :param delivery_to: Limits the contracts to those with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param delivery_areas: Limit the search to contracts that belong to any of the specified delivery areas.
        :type delivery_areas: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_contracts_serialize(
            contract_id=contract_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            delivery_areas=delivery_areas,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ContractItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_contracts_without_preload_content(
        self,
        contract_id: Optional[List[StrictStr]] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="Limit the contracts to those with the given delivery start date.")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="Limit the contracts to those with the given delivery end date.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the contracts to those with a delivery start date >= delivery_from.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the contracts to those with a delivery end date <= delivery_to.")] = None,
        delivery_areas: Annotated[Optional[List[StrictStr]], Field(description="Limit the search to contracts that belong to any of the specified delivery areas.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find contracts

        This method allows you to find active or historical contracts based on their exact delivery_start and delivery_end time (UTC) and lets you determine their contract_id. Using delivery_from and delivery_to, the contracts can be further limited to a given timespan.

        :param contract_id:
        :type contract_id: List[str]
        :param delivery_start: Limit the contracts to those with the given delivery start date.
        :type delivery_start: datetime
        :param delivery_end: Limit the contracts to those with the given delivery end date.
        :type delivery_end: datetime
        :param delivery_from: Limits the contracts to those with a delivery start date >= delivery_from.
        :type delivery_from: datetime
        :param delivery_to: Limits the contracts to those with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param delivery_areas: Limit the search to contracts that belong to any of the specified delivery areas.
        :type delivery_areas: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_contracts_serialize(
            contract_id=contract_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            delivery_areas=delivery_areas,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ContractItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_contracts_serialize(
        self,
        contract_id,
        delivery_start,
        delivery_end,
        delivery_from,
        delivery_to,
        delivery_areas,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'contract_id': 'csv',
            'delivery_areas': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if contract_id is not None:
            
            _query_params.append(('contract_id', contract_id))
            
        if delivery_start is not None:
            if isinstance(delivery_start, datetime):
                _query_params.append(
                    (
                        'delivery_start',
                        delivery_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_start', delivery_start))
            
        if delivery_end is not None:
            if isinstance(delivery_end, datetime):
                _query_params.append(
                    (
                        'delivery_end',
                        delivery_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_end', delivery_end))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        if delivery_areas is not None:
            
            _query_params.append(('delivery_areas', delivery_areas))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contracts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_contract_history(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="DEPRECATED: use page_token instead.  Offset when loading a list of items")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Used for request pagination. For every retrieved page, the header `X-Next-Page-Token` will be set. Provide this value as the `page_token` parameter to retrieve the next page of results. The first request does not need to have the `page_token` parameter set.  This value can only be used in conjunction with `limit`.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        portfolio_id: Optional[List[StrictStr]] = None,
        from_revision: Annotated[Optional[StrictInt], Field(description="Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.")] = None,
        to_revision: Annotated[Optional[StrictInt], Field(description="Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.")] = None,
        from_time: Annotated[Optional[datetime], Field(description="The time of the first revision to retrieve (inclusive)")] = None,
        to_time: Annotated[Optional[datetime], Field(description="The time of the last revision to retrieve (inclusive)")] = None,
        as_of: Annotated[Optional[datetime], Field(description="Contract history as_of given point in time. Cannot be combined together with from_revision and to_revision.")] = None,
        with_owntrades: Annotated[Optional[StrictBool], Field(description="If set to true, the own trades which happened on that revision are returned.")] = None,
        with_signals: Annotated[Optional[StrictBool], Field(description="If set to true, the signals valid for that revision are returned.")] = None,
        with_orders: Annotated[Optional[StrictBool], Field(description="If set to true, details about bids/asks are returned")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="DEPRECATED: sorting manually by time or revision can lead to inconsistent results. Leaving this blank will always return revisions exactly as received by the exchange. If you require the revisions in descending order, please reverse the returned list manually.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ContractHistoryItem]:
        """Get contract history

        This method allows you to retrieve the history of a contract in a delivery area in the form of revisions (which include delta and sometimes full orderbook updates). When querying with a list of portfolios, you can retrieve all your own trades and signals that belong to the contract. When querying with a timestamp in \"as_of\", you can retrieve the contract history at a given point in time, or you can request a set of revisions.  If with_orders is set to true, the revisions will include new and deleted orders that belong to the revision (if requesting revisions) in delta-format or the full orderbook if requesting a historical version using \"as_of\".  Please note that this feature uses pagination.

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param offset: DEPRECATED: use page_token instead.  Offset when loading a list of items
        :type offset: int
        :param page_token: Used for request pagination. For every retrieved page, the header `X-Next-Page-Token` will be set. Provide this value as the `page_token` parameter to retrieve the next page of results. The first request does not need to have the `page_token` parameter set.  This value can only be used in conjunction with `limit`.
        :type page_token: str
        :param limit: Limits the number of loaded items
        :type limit: int
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param from_revision: Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.
        :type from_revision: int
        :param to_revision: Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.
        :type to_revision: int
        :param from_time: The time of the first revision to retrieve (inclusive)
        :type from_time: datetime
        :param to_time: The time of the last revision to retrieve (inclusive)
        :type to_time: datetime
        :param as_of: Contract history as_of given point in time. Cannot be combined together with from_revision and to_revision.
        :type as_of: datetime
        :param with_owntrades: If set to true, the own trades which happened on that revision are returned.
        :type with_owntrades: bool
        :param with_signals: If set to true, the signals valid for that revision are returned.
        :type with_signals: bool
        :param with_orders: If set to true, details about bids/asks are returned
        :type with_orders: bool
        :param sort_by: DEPRECATED: sorting manually by time or revision can lead to inconsistent results. Leaving this blank will always return revisions exactly as received by the exchange. If you require the revisions in descending order, please reverse the returned list manually.
        :type sort_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contract_history_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            offset=offset,
            page_token=page_token,
            limit=limit,
            portfolio_id=portfolio_id,
            from_revision=from_revision,
            to_revision=to_revision,
            from_time=from_time,
            to_time=to_time,
            as_of=as_of,
            with_owntrades=with_owntrades,
            with_signals=with_signals,
            with_orders=with_orders,
            sort_by=sort_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ContractHistoryItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_contract_history_with_http_info(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="DEPRECATED: use page_token instead.  Offset when loading a list of items")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Used for request pagination. For every retrieved page, the header `X-Next-Page-Token` will be set. Provide this value as the `page_token` parameter to retrieve the next page of results. The first request does not need to have the `page_token` parameter set.  This value can only be used in conjunction with `limit`.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        portfolio_id: Optional[List[StrictStr]] = None,
        from_revision: Annotated[Optional[StrictInt], Field(description="Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.")] = None,
        to_revision: Annotated[Optional[StrictInt], Field(description="Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.")] = None,
        from_time: Annotated[Optional[datetime], Field(description="The time of the first revision to retrieve (inclusive)")] = None,
        to_time: Annotated[Optional[datetime], Field(description="The time of the last revision to retrieve (inclusive)")] = None,
        as_of: Annotated[Optional[datetime], Field(description="Contract history as_of given point in time. Cannot be combined together with from_revision and to_revision.")] = None,
        with_owntrades: Annotated[Optional[StrictBool], Field(description="If set to true, the own trades which happened on that revision are returned.")] = None,
        with_signals: Annotated[Optional[StrictBool], Field(description="If set to true, the signals valid for that revision are returned.")] = None,
        with_orders: Annotated[Optional[StrictBool], Field(description="If set to true, details about bids/asks are returned")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="DEPRECATED: sorting manually by time or revision can lead to inconsistent results. Leaving this blank will always return revisions exactly as received by the exchange. If you require the revisions in descending order, please reverse the returned list manually.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ContractHistoryItem]]:
        """Get contract history

        This method allows you to retrieve the history of a contract in a delivery area in the form of revisions (which include delta and sometimes full orderbook updates). When querying with a list of portfolios, you can retrieve all your own trades and signals that belong to the contract. When querying with a timestamp in \"as_of\", you can retrieve the contract history at a given point in time, or you can request a set of revisions.  If with_orders is set to true, the revisions will include new and deleted orders that belong to the revision (if requesting revisions) in delta-format or the full orderbook if requesting a historical version using \"as_of\".  Please note that this feature uses pagination.

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param offset: DEPRECATED: use page_token instead.  Offset when loading a list of items
        :type offset: int
        :param page_token: Used for request pagination. For every retrieved page, the header `X-Next-Page-Token` will be set. Provide this value as the `page_token` parameter to retrieve the next page of results. The first request does not need to have the `page_token` parameter set.  This value can only be used in conjunction with `limit`.
        :type page_token: str
        :param limit: Limits the number of loaded items
        :type limit: int
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param from_revision: Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.
        :type from_revision: int
        :param to_revision: Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.
        :type to_revision: int
        :param from_time: The time of the first revision to retrieve (inclusive)
        :type from_time: datetime
        :param to_time: The time of the last revision to retrieve (inclusive)
        :type to_time: datetime
        :param as_of: Contract history as_of given point in time. Cannot be combined together with from_revision and to_revision.
        :type as_of: datetime
        :param with_owntrades: If set to true, the own trades which happened on that revision are returned.
        :type with_owntrades: bool
        :param with_signals: If set to true, the signals valid for that revision are returned.
        :type with_signals: bool
        :param with_orders: If set to true, details about bids/asks are returned
        :type with_orders: bool
        :param sort_by: DEPRECATED: sorting manually by time or revision can lead to inconsistent results. Leaving this blank will always return revisions exactly as received by the exchange. If you require the revisions in descending order, please reverse the returned list manually.
        :type sort_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contract_history_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            offset=offset,
            page_token=page_token,
            limit=limit,
            portfolio_id=portfolio_id,
            from_revision=from_revision,
            to_revision=to_revision,
            from_time=from_time,
            to_time=to_time,
            as_of=as_of,
            with_owntrades=with_owntrades,
            with_signals=with_signals,
            with_orders=with_orders,
            sort_by=sort_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ContractHistoryItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_contract_history_without_preload_content(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="DEPRECATED: use page_token instead.  Offset when loading a list of items")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Used for request pagination. For every retrieved page, the header `X-Next-Page-Token` will be set. Provide this value as the `page_token` parameter to retrieve the next page of results. The first request does not need to have the `page_token` parameter set.  This value can only be used in conjunction with `limit`.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        portfolio_id: Optional[List[StrictStr]] = None,
        from_revision: Annotated[Optional[StrictInt], Field(description="Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.")] = None,
        to_revision: Annotated[Optional[StrictInt], Field(description="Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.")] = None,
        from_time: Annotated[Optional[datetime], Field(description="The time of the first revision to retrieve (inclusive)")] = None,
        to_time: Annotated[Optional[datetime], Field(description="The time of the last revision to retrieve (inclusive)")] = None,
        as_of: Annotated[Optional[datetime], Field(description="Contract history as_of given point in time. Cannot be combined together with from_revision and to_revision.")] = None,
        with_owntrades: Annotated[Optional[StrictBool], Field(description="If set to true, the own trades which happened on that revision are returned.")] = None,
        with_signals: Annotated[Optional[StrictBool], Field(description="If set to true, the signals valid for that revision are returned.")] = None,
        with_orders: Annotated[Optional[StrictBool], Field(description="If set to true, details about bids/asks are returned")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="DEPRECATED: sorting manually by time or revision can lead to inconsistent results. Leaving this blank will always return revisions exactly as received by the exchange. If you require the revisions in descending order, please reverse the returned list manually.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get contract history

        This method allows you to retrieve the history of a contract in a delivery area in the form of revisions (which include delta and sometimes full orderbook updates). When querying with a list of portfolios, you can retrieve all your own trades and signals that belong to the contract. When querying with a timestamp in \"as_of\", you can retrieve the contract history at a given point in time, or you can request a set of revisions.  If with_orders is set to true, the revisions will include new and deleted orders that belong to the revision (if requesting revisions) in delta-format or the full orderbook if requesting a historical version using \"as_of\".  Please note that this feature uses pagination.

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param offset: DEPRECATED: use page_token instead.  Offset when loading a list of items
        :type offset: int
        :param page_token: Used for request pagination. For every retrieved page, the header `X-Next-Page-Token` will be set. Provide this value as the `page_token` parameter to retrieve the next page of results. The first request does not need to have the `page_token` parameter set.  This value can only be used in conjunction with `limit`.
        :type page_token: str
        :param limit: Limits the number of loaded items
        :type limit: int
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param from_revision: Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.
        :type from_revision: int
        :param to_revision: Revisions start with 0, each change increments it by 1. Please note that only up to 500 revisions at a time can be fetched.
        :type to_revision: int
        :param from_time: The time of the first revision to retrieve (inclusive)
        :type from_time: datetime
        :param to_time: The time of the last revision to retrieve (inclusive)
        :type to_time: datetime
        :param as_of: Contract history as_of given point in time. Cannot be combined together with from_revision and to_revision.
        :type as_of: datetime
        :param with_owntrades: If set to true, the own trades which happened on that revision are returned.
        :type with_owntrades: bool
        :param with_signals: If set to true, the signals valid for that revision are returned.
        :type with_signals: bool
        :param with_orders: If set to true, details about bids/asks are returned
        :type with_orders: bool
        :param sort_by: DEPRECATED: sorting manually by time or revision can lead to inconsistent results. Leaving this blank will always return revisions exactly as received by the exchange. If you require the revisions in descending order, please reverse the returned list manually.
        :type sort_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contract_history_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            offset=offset,
            page_token=page_token,
            limit=limit,
            portfolio_id=portfolio_id,
            from_revision=from_revision,
            to_revision=to_revision,
            from_time=from_time,
            to_time=to_time,
            as_of=as_of,
            with_owntrades=with_owntrades,
            with_signals=with_signals,
            with_orders=with_orders,
            sort_by=sort_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ContractHistoryItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_contract_history_serialize(
        self,
        contract_id,
        delivery_area,
        offset,
        page_token,
        limit,
        portfolio_id,
        from_revision,
        to_revision,
        from_time,
        to_time,
        as_of,
        with_owntrades,
        with_signals,
        with_orders,
        sort_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'portfolio_id': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if contract_id is not None:
            _path_params['contract_id'] = contract_id
        if delivery_area is not None:
            _path_params['delivery_area'] = delivery_area
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if page_token is not None:
            
            _query_params.append(('page_token', page_token))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if from_revision is not None:
            
            _query_params.append(('from_revision', from_revision))
            
        if to_revision is not None:
            
            _query_params.append(('to_revision', to_revision))
            
        if from_time is not None:
            if isinstance(from_time, datetime):
                _query_params.append(
                    (
                        'from_time',
                        from_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('from_time', from_time))
            
        if to_time is not None:
            if isinstance(to_time, datetime):
                _query_params.append(
                    (
                        'to_time',
                        to_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('to_time', to_time))
            
        if as_of is not None:
            if isinstance(as_of, datetime):
                _query_params.append(
                    (
                        'as_of',
                        as_of.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('as_of', as_of))
            
        if with_owntrades is not None:
            
            _query_params.append(('with_owntrades', with_owntrades))
            
        if with_signals is not None:
            
            _query_params.append(('with_signals', with_signals))
            
        if with_orders is not None:
            
            _query_params.append(('with_orders', with_orders))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contract/{contract_id}/{delivery_area}/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_contract_signals(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Signal]:
        """Get contract signals

        This method allows you to retrieve your trading signals (your positions or custom data like weather, fundamental data etc.) valid for a contract in a delivery area for one or more portfolios.

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contract_signals_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_contract_signals_with_http_info(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Signal]]:
        """Get contract signals

        This method allows you to retrieve your trading signals (your positions or custom data like weather, fundamental data etc.) valid for a contract in a delivery area for one or more portfolios.

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contract_signals_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_contract_signals_without_preload_content(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get contract signals

        This method allows you to retrieve your trading signals (your positions or custom data like weather, fundamental data etc.) valid for a contract in a delivery area for one or more portfolios.

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contract_signals_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_contract_signals_serialize(
        self,
        contract_id,
        delivery_area,
        portfolio_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'portfolio_id': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if contract_id is not None:
            _path_params['contract_id'] = contract_id
        if delivery_area is not None:
            _path_params['delivery_area'] = delivery_area
        # process the query parameters
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contract/{contract_id}/{delivery_area}/signals',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_limits(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Optional[List[StrictStr]] = None,
        with_auction_positions: Annotated[Optional[StrictBool], Field(description="If set to true, the returned portfolio information will contain the auction positions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RiskSettingsAndPortfolioInformation:
        """Get contract portfolio information

        Calculates the current positions (portfolio-information) for a given contract. The response contains information about   - the currency of all parameters   - order-to-trade-ratios for the exchange, tenant and portfolio (DEPRECATED: replaced by order action quota)   - cash-positions   - net-positions   - order-action-quota-limits

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param with_auction_positions: If set to true, the returned portfolio information will contain the auction positions
        :type with_auction_positions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_limits_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            with_auction_positions=with_auction_positions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RiskSettingsAndPortfolioInformation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_limits_with_http_info(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Optional[List[StrictStr]] = None,
        with_auction_positions: Annotated[Optional[StrictBool], Field(description="If set to true, the returned portfolio information will contain the auction positions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RiskSettingsAndPortfolioInformation]:
        """Get contract portfolio information

        Calculates the current positions (portfolio-information) for a given contract. The response contains information about   - the currency of all parameters   - order-to-trade-ratios for the exchange, tenant and portfolio (DEPRECATED: replaced by order action quota)   - cash-positions   - net-positions   - order-action-quota-limits

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param with_auction_positions: If set to true, the returned portfolio information will contain the auction positions
        :type with_auction_positions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_limits_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            with_auction_positions=with_auction_positions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RiskSettingsAndPortfolioInformation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_limits_without_preload_content(
        self,
        contract_id: Annotated[StrictStr, Field(description="The unique id of the contract")],
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Optional[List[StrictStr]] = None,
        with_auction_positions: Annotated[Optional[StrictBool], Field(description="If set to true, the returned portfolio information will contain the auction positions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get contract portfolio information

        Calculates the current positions (portfolio-information) for a given contract. The response contains information about   - the currency of all parameters   - order-to-trade-ratios for the exchange, tenant and portfolio (DEPRECATED: replaced by order action quota)   - cash-positions   - net-positions   - order-action-quota-limits

        :param contract_id: The unique id of the contract (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param with_auction_positions: If set to true, the returned portfolio information will contain the auction positions
        :type with_auction_positions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_limits_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            with_auction_positions=with_auction_positions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RiskSettingsAndPortfolioInformation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_limits_serialize(
        self,
        contract_id,
        delivery_area,
        portfolio_id,
        with_auction_positions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'portfolio_id': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if contract_id is not None:
            _path_params['contract_id'] = contract_id
        if delivery_area is not None:
            _path_params['delivery_area'] = delivery_area
        # process the query parameters
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if with_auction_positions is not None:
            
            _query_params.append(('with_auction_positions', with_auction_positions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contract/{contract_id}/{delivery_area}/portfolio-information',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order_book_statistics(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the requested delivery area.")],
        contract_duration_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The duration of the contracts to calculate statistics for. Must be a multiple of 15 minutes.")] = None,
        order_book_depth: Annotated[Optional[List[Union[StrictFloat, StrictInt]]], Field(description="List of order book depths (in MW) to calculate the average price for each contract.")] = None,
        products: Annotated[Optional[List[StrictStr]], Field(description="List of products (e.g. Intraday_Power_D,XBID_Hour_Power) to consider in the calculation. Leave blank if you want all available products considered.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the order book to those contracts with a delivery start date >= delivery_from.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the order book to those contracts with a delivery end date <= delivery_to.")] = None,
        exclude_own_orders: Annotated[Optional[StrictBool], Field(description="If true, own orders are not considered in the calculation of the order book vwaps.")] = None,
        portfolio_id: Annotated[Optional[StrictStr], Field(description="Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book and included in the calculation. An error is returned if a non shadow trading portfolio ID is given.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderBookBulkStatistics:
        """Get order book statistics

        Provides a summary of statistics for each contract which is currently active in the order book. Additionally, the average price for given order book depths can be calculated.

        :param delivery_area: The EIC of the requested delivery area. (required)
        :type delivery_area: str
        :param contract_duration_minutes: The duration of the contracts to calculate statistics for. Must be a multiple of 15 minutes.
        :type contract_duration_minutes: int
        :param order_book_depth: List of order book depths (in MW) to calculate the average price for each contract.
        :type order_book_depth: List[float]
        :param products: List of products (e.g. Intraday_Power_D,XBID_Hour_Power) to consider in the calculation. Leave blank if you want all available products considered.
        :type products: List[str]
        :param delivery_from: Limits the order book to those contracts with a delivery start date >= delivery_from.
        :type delivery_from: datetime
        :param delivery_to: Limits the order book to those contracts with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param exclude_own_orders: If true, own orders are not considered in the calculation of the order book vwaps.
        :type exclude_own_orders: bool
        :param portfolio_id: Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book and included in the calculation. An error is returned if a non shadow trading portfolio ID is given.
        :type portfolio_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_book_statistics_serialize(
            delivery_area=delivery_area,
            contract_duration_minutes=contract_duration_minutes,
            order_book_depth=order_book_depth,
            products=products,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            exclude_own_orders=exclude_own_orders,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookBulkStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_book_statistics_with_http_info(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the requested delivery area.")],
        contract_duration_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The duration of the contracts to calculate statistics for. Must be a multiple of 15 minutes.")] = None,
        order_book_depth: Annotated[Optional[List[Union[StrictFloat, StrictInt]]], Field(description="List of order book depths (in MW) to calculate the average price for each contract.")] = None,
        products: Annotated[Optional[List[StrictStr]], Field(description="List of products (e.g. Intraday_Power_D,XBID_Hour_Power) to consider in the calculation. Leave blank if you want all available products considered.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the order book to those contracts with a delivery start date >= delivery_from.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the order book to those contracts with a delivery end date <= delivery_to.")] = None,
        exclude_own_orders: Annotated[Optional[StrictBool], Field(description="If true, own orders are not considered in the calculation of the order book vwaps.")] = None,
        portfolio_id: Annotated[Optional[StrictStr], Field(description="Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book and included in the calculation. An error is returned if a non shadow trading portfolio ID is given.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderBookBulkStatistics]:
        """Get order book statistics

        Provides a summary of statistics for each contract which is currently active in the order book. Additionally, the average price for given order book depths can be calculated.

        :param delivery_area: The EIC of the requested delivery area. (required)
        :type delivery_area: str
        :param contract_duration_minutes: The duration of the contracts to calculate statistics for. Must be a multiple of 15 minutes.
        :type contract_duration_minutes: int
        :param order_book_depth: List of order book depths (in MW) to calculate the average price for each contract.
        :type order_book_depth: List[float]
        :param products: List of products (e.g. Intraday_Power_D,XBID_Hour_Power) to consider in the calculation. Leave blank if you want all available products considered.
        :type products: List[str]
        :param delivery_from: Limits the order book to those contracts with a delivery start date >= delivery_from.
        :type delivery_from: datetime
        :param delivery_to: Limits the order book to those contracts with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param exclude_own_orders: If true, own orders are not considered in the calculation of the order book vwaps.
        :type exclude_own_orders: bool
        :param portfolio_id: Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book and included in the calculation. An error is returned if a non shadow trading portfolio ID is given.
        :type portfolio_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_book_statistics_serialize(
            delivery_area=delivery_area,
            contract_duration_minutes=contract_duration_minutes,
            order_book_depth=order_book_depth,
            products=products,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            exclude_own_orders=exclude_own_orders,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookBulkStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_book_statistics_without_preload_content(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the requested delivery area.")],
        contract_duration_minutes: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The duration of the contracts to calculate statistics for. Must be a multiple of 15 minutes.")] = None,
        order_book_depth: Annotated[Optional[List[Union[StrictFloat, StrictInt]]], Field(description="List of order book depths (in MW) to calculate the average price for each contract.")] = None,
        products: Annotated[Optional[List[StrictStr]], Field(description="List of products (e.g. Intraday_Power_D,XBID_Hour_Power) to consider in the calculation. Leave blank if you want all available products considered.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the order book to those contracts with a delivery start date >= delivery_from.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the order book to those contracts with a delivery end date <= delivery_to.")] = None,
        exclude_own_orders: Annotated[Optional[StrictBool], Field(description="If true, own orders are not considered in the calculation of the order book vwaps.")] = None,
        portfolio_id: Annotated[Optional[StrictStr], Field(description="Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book and included in the calculation. An error is returned if a non shadow trading portfolio ID is given.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get order book statistics

        Provides a summary of statistics for each contract which is currently active in the order book. Additionally, the average price for given order book depths can be calculated.

        :param delivery_area: The EIC of the requested delivery area. (required)
        :type delivery_area: str
        :param contract_duration_minutes: The duration of the contracts to calculate statistics for. Must be a multiple of 15 minutes.
        :type contract_duration_minutes: int
        :param order_book_depth: List of order book depths (in MW) to calculate the average price for each contract.
        :type order_book_depth: List[float]
        :param products: List of products (e.g. Intraday_Power_D,XBID_Hour_Power) to consider in the calculation. Leave blank if you want all available products considered.
        :type products: List[str]
        :param delivery_from: Limits the order book to those contracts with a delivery start date >= delivery_from.
        :type delivery_from: datetime
        :param delivery_to: Limits the order book to those contracts with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param exclude_own_orders: If true, own orders are not considered in the calculation of the order book vwaps.
        :type exclude_own_orders: bool
        :param portfolio_id: Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book and included in the calculation. An error is returned if a non shadow trading portfolio ID is given.
        :type portfolio_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_book_statistics_serialize(
            delivery_area=delivery_area,
            contract_duration_minutes=contract_duration_minutes,
            order_book_depth=order_book_depth,
            products=products,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            exclude_own_orders=exclude_own_orders,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookBulkStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_book_statistics_serialize(
        self,
        delivery_area,
        contract_duration_minutes,
        order_book_depth,
        products,
        delivery_from,
        delivery_to,
        exclude_own_orders,
        portfolio_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'order_book_depth': 'multi',
            'products': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if contract_duration_minutes is not None:
            
            _query_params.append(('contract_duration_minutes', contract_duration_minutes))
            
        if order_book_depth is not None:
            
            _query_params.append(('order_book_depth', order_book_depth))
            
        if products is not None:
            
            _query_params.append(('products', products))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        if exclude_own_orders is not None:
            
            _query_params.append(('exclude_own_orders', exclude_own_orders))
            
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contracts/orderbookbulkstatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order_books(
        self,
        portfolio_id: Annotated[Optional[List[StrictStr]], Field(description="Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book.  **Note**: you must set this parameter if you want to see shadow trading changes applied.")] = None,
        product: Annotated[Optional[StrictStr], Field(description="DEPRECATED, use `products` instead. The list of products (e.g. Intraday_Power_D,XBID_Hour_Power) *separated by a comma*, for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks")] = None,
        products: Annotated[Optional[List[StrictStr]], Field(description="The list of products (e.g. Intraday_Power_D,XBID_Hour_Power), for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks")] = None,
        with_bid_or_ask_only: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask")] = None,
        with_signals: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain the signals applicable for the contracts")] = None,
        contract_id: Annotated[Optional[List[StrictStr]], Field(description="limit the orderbook to an array of certain contracts only")] = None,
        contract_name: Annotated[Optional[StrictStr], Field(description="limit the orderbook to a certain contract name only")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts with the given delivery start date")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts with the given delivery end date")] = None,
        delivery_within: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter")] = None,
        past_hours: Annotated[Optional[Annotated[int, Field(le=24, strict=True, ge=0)]], Field(description="DEPRECATED: Please use `delivery_from` in combination with `active_only=false`. The number of hours to look into the past in the orderbook. If this parameter is set, historic closed contracts are contained in the orderbook as well. Cannot be used in conjunction with delivery_from.")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="The EIC of the delivery area of the orderbook")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the orderbook to those contracts with a delivery start date >= delivery_from. Cannot be used in conjunction with past_hours.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the orderbook to those contracts with a delivery end date <= delivery_to.")] = None,
        with_order_details: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain all current bids and asks of each contract (full orderbook depth). *Heads up* We generally recommend to request the full orderbook depth on a per contract basis when orderbook-changed notifications are received via websocket. If you need the full orderbook depth for all contracts at once more frequently, please consider using full orderbook snapshots via websocket.")] = None,
        contract_type: Annotated[Optional[ContractType], Field(description="**PDC**: (default) the order book only includes predefined contracts, i.e. the normal contracts generated by the backend  UDC: the order book only includes block products, which were created as the result of a block order submitted by a member  ALL: the order book contains both, PDC and UDC contracts")] = None,
        with_portfolio_information: Annotated[Optional[StrictBool], Field(description="If set to true, the portfolio_information is included in the response.")] = None,
        with_risk_settings: Annotated[Optional[StrictBool], Field(description="If set to true, the risk_setting of the portfolio are included in the response.")] = None,
        with_products: Annotated[Optional[StrictBool], Field(description="If set to true, the available products are included in the response.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Setting this to false will also return order books for expired/inactive contracts.")] = None,
        with_auction_positions: Annotated[Optional[StrictBool], Field(description="If set to true, the auction positions are included in the response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderBooks:
        """Get all orderbooks

        Shows the public order book for the requested products (or all available products) for a given delivery_area. Default delivery area will be applied if left blank and default is set. This request will by default only deliver the order book statistics (best bid, best ask, last etc.) and does not include the full orderbook depth. If you wish to retrieve the full order book you can set with_order_details to \"true\". However, this should only be done if absolutely necessary, as it will negatively impact the performance. Alternatively you can request the full order book with GET /contract/contract_id/delivery_area/orders.  The order book contains portfolio relevant data (like net_position, signals etc.) and can thus be filtered by a list of portfolio IDs. Setting the limit parameter allows to limit the number of entries returned per request (sorted by ascending delivery time).  The filter with_bid_or_ask_only returns only non empty order books. If past_hours is set, the orderbook will include historical contracts that have been closed in the last X hours.  Using delivery_from and delivery_to, the order book can be further limited to a given timespan.

        :param portfolio_id: Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book.  **Note**: you must set this parameter if you want to see shadow trading changes applied.
        :type portfolio_id: List[str]
        :param product: DEPRECATED, use `products` instead. The list of products (e.g. Intraday_Power_D,XBID_Hour_Power) *separated by a comma*, for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks
        :type product: str
        :param products: The list of products (e.g. Intraday_Power_D,XBID_Hour_Power), for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks
        :type products: List[str]
        :param with_bid_or_ask_only: If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask
        :type with_bid_or_ask_only: bool
        :param with_signals: If set to true, the returned orderbook will contain the signals applicable for the contracts
        :type with_signals: bool
        :param contract_id: limit the orderbook to an array of certain contracts only
        :type contract_id: List[str]
        :param contract_name: limit the orderbook to a certain contract name only
        :type contract_name: str
        :param delivery_start: limit the orderbook to those contracts with the given delivery start date
        :type delivery_start: datetime
        :param delivery_end: limit the orderbook to those contracts with the given delivery end date
        :type delivery_end: datetime
        :param delivery_within: limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter
        :type delivery_within: datetime
        :param past_hours: DEPRECATED: Please use `delivery_from` in combination with `active_only=false`. The number of hours to look into the past in the orderbook. If this parameter is set, historic closed contracts are contained in the orderbook as well. Cannot be used in conjunction with delivery_from.
        :type past_hours: int
        :param delivery_area: The EIC of the delivery area of the orderbook
        :type delivery_area: str
        :param delivery_from: Limits the orderbook to those contracts with a delivery start date >= delivery_from. Cannot be used in conjunction with past_hours.
        :type delivery_from: datetime
        :param delivery_to: Limits the orderbook to those contracts with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param with_order_details: If set to true, the returned orderbook will contain all current bids and asks of each contract (full orderbook depth). *Heads up* We generally recommend to request the full orderbook depth on a per contract basis when orderbook-changed notifications are received via websocket. If you need the full orderbook depth for all contracts at once more frequently, please consider using full orderbook snapshots via websocket.
        :type with_order_details: bool
        :param contract_type: **PDC**: (default) the order book only includes predefined contracts, i.e. the normal contracts generated by the backend  UDC: the order book only includes block products, which were created as the result of a block order submitted by a member  ALL: the order book contains both, PDC and UDC contracts
        :type contract_type: ContractType
        :param with_portfolio_information: If set to true, the portfolio_information is included in the response.
        :type with_portfolio_information: bool
        :param with_risk_settings: If set to true, the risk_setting of the portfolio are included in the response.
        :type with_risk_settings: bool
        :param with_products: If set to true, the available products are included in the response.
        :type with_products: bool
        :param active_only: Setting this to false will also return order books for expired/inactive contracts.
        :type active_only: bool
        :param with_auction_positions: If set to true, the auction positions are included in the response.
        :type with_auction_positions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_books_serialize(
            portfolio_id=portfolio_id,
            product=product,
            products=products,
            with_bid_or_ask_only=with_bid_or_ask_only,
            with_signals=with_signals,
            contract_id=contract_id,
            contract_name=contract_name,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_within=delivery_within,
            past_hours=past_hours,
            delivery_area=delivery_area,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            with_order_details=with_order_details,
            contract_type=contract_type,
            with_portfolio_information=with_portfolio_information,
            with_risk_settings=with_risk_settings,
            with_products=with_products,
            active_only=active_only,
            with_auction_positions=with_auction_positions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBooks",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_books_with_http_info(
        self,
        portfolio_id: Annotated[Optional[List[StrictStr]], Field(description="Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book.  **Note**: you must set this parameter if you want to see shadow trading changes applied.")] = None,
        product: Annotated[Optional[StrictStr], Field(description="DEPRECATED, use `products` instead. The list of products (e.g. Intraday_Power_D,XBID_Hour_Power) *separated by a comma*, for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks")] = None,
        products: Annotated[Optional[List[StrictStr]], Field(description="The list of products (e.g. Intraday_Power_D,XBID_Hour_Power), for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks")] = None,
        with_bid_or_ask_only: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask")] = None,
        with_signals: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain the signals applicable for the contracts")] = None,
        contract_id: Annotated[Optional[List[StrictStr]], Field(description="limit the orderbook to an array of certain contracts only")] = None,
        contract_name: Annotated[Optional[StrictStr], Field(description="limit the orderbook to a certain contract name only")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts with the given delivery start date")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts with the given delivery end date")] = None,
        delivery_within: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter")] = None,
        past_hours: Annotated[Optional[Annotated[int, Field(le=24, strict=True, ge=0)]], Field(description="DEPRECATED: Please use `delivery_from` in combination with `active_only=false`. The number of hours to look into the past in the orderbook. If this parameter is set, historic closed contracts are contained in the orderbook as well. Cannot be used in conjunction with delivery_from.")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="The EIC of the delivery area of the orderbook")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the orderbook to those contracts with a delivery start date >= delivery_from. Cannot be used in conjunction with past_hours.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the orderbook to those contracts with a delivery end date <= delivery_to.")] = None,
        with_order_details: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain all current bids and asks of each contract (full orderbook depth). *Heads up* We generally recommend to request the full orderbook depth on a per contract basis when orderbook-changed notifications are received via websocket. If you need the full orderbook depth for all contracts at once more frequently, please consider using full orderbook snapshots via websocket.")] = None,
        contract_type: Annotated[Optional[ContractType], Field(description="**PDC**: (default) the order book only includes predefined contracts, i.e. the normal contracts generated by the backend  UDC: the order book only includes block products, which were created as the result of a block order submitted by a member  ALL: the order book contains both, PDC and UDC contracts")] = None,
        with_portfolio_information: Annotated[Optional[StrictBool], Field(description="If set to true, the portfolio_information is included in the response.")] = None,
        with_risk_settings: Annotated[Optional[StrictBool], Field(description="If set to true, the risk_setting of the portfolio are included in the response.")] = None,
        with_products: Annotated[Optional[StrictBool], Field(description="If set to true, the available products are included in the response.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Setting this to false will also return order books for expired/inactive contracts.")] = None,
        with_auction_positions: Annotated[Optional[StrictBool], Field(description="If set to true, the auction positions are included in the response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderBooks]:
        """Get all orderbooks

        Shows the public order book for the requested products (or all available products) for a given delivery_area. Default delivery area will be applied if left blank and default is set. This request will by default only deliver the order book statistics (best bid, best ask, last etc.) and does not include the full orderbook depth. If you wish to retrieve the full order book you can set with_order_details to \"true\". However, this should only be done if absolutely necessary, as it will negatively impact the performance. Alternatively you can request the full order book with GET /contract/contract_id/delivery_area/orders.  The order book contains portfolio relevant data (like net_position, signals etc.) and can thus be filtered by a list of portfolio IDs. Setting the limit parameter allows to limit the number of entries returned per request (sorted by ascending delivery time).  The filter with_bid_or_ask_only returns only non empty order books. If past_hours is set, the orderbook will include historical contracts that have been closed in the last X hours.  Using delivery_from and delivery_to, the order book can be further limited to a given timespan.

        :param portfolio_id: Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book.  **Note**: you must set this parameter if you want to see shadow trading changes applied.
        :type portfolio_id: List[str]
        :param product: DEPRECATED, use `products` instead. The list of products (e.g. Intraday_Power_D,XBID_Hour_Power) *separated by a comma*, for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks
        :type product: str
        :param products: The list of products (e.g. Intraday_Power_D,XBID_Hour_Power), for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks
        :type products: List[str]
        :param with_bid_or_ask_only: If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask
        :type with_bid_or_ask_only: bool
        :param with_signals: If set to true, the returned orderbook will contain the signals applicable for the contracts
        :type with_signals: bool
        :param contract_id: limit the orderbook to an array of certain contracts only
        :type contract_id: List[str]
        :param contract_name: limit the orderbook to a certain contract name only
        :type contract_name: str
        :param delivery_start: limit the orderbook to those contracts with the given delivery start date
        :type delivery_start: datetime
        :param delivery_end: limit the orderbook to those contracts with the given delivery end date
        :type delivery_end: datetime
        :param delivery_within: limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter
        :type delivery_within: datetime
        :param past_hours: DEPRECATED: Please use `delivery_from` in combination with `active_only=false`. The number of hours to look into the past in the orderbook. If this parameter is set, historic closed contracts are contained in the orderbook as well. Cannot be used in conjunction with delivery_from.
        :type past_hours: int
        :param delivery_area: The EIC of the delivery area of the orderbook
        :type delivery_area: str
        :param delivery_from: Limits the orderbook to those contracts with a delivery start date >= delivery_from. Cannot be used in conjunction with past_hours.
        :type delivery_from: datetime
        :param delivery_to: Limits the orderbook to those contracts with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param with_order_details: If set to true, the returned orderbook will contain all current bids and asks of each contract (full orderbook depth). *Heads up* We generally recommend to request the full orderbook depth on a per contract basis when orderbook-changed notifications are received via websocket. If you need the full orderbook depth for all contracts at once more frequently, please consider using full orderbook snapshots via websocket.
        :type with_order_details: bool
        :param contract_type: **PDC**: (default) the order book only includes predefined contracts, i.e. the normal contracts generated by the backend  UDC: the order book only includes block products, which were created as the result of a block order submitted by a member  ALL: the order book contains both, PDC and UDC contracts
        :type contract_type: ContractType
        :param with_portfolio_information: If set to true, the portfolio_information is included in the response.
        :type with_portfolio_information: bool
        :param with_risk_settings: If set to true, the risk_setting of the portfolio are included in the response.
        :type with_risk_settings: bool
        :param with_products: If set to true, the available products are included in the response.
        :type with_products: bool
        :param active_only: Setting this to false will also return order books for expired/inactive contracts.
        :type active_only: bool
        :param with_auction_positions: If set to true, the auction positions are included in the response.
        :type with_auction_positions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_books_serialize(
            portfolio_id=portfolio_id,
            product=product,
            products=products,
            with_bid_or_ask_only=with_bid_or_ask_only,
            with_signals=with_signals,
            contract_id=contract_id,
            contract_name=contract_name,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_within=delivery_within,
            past_hours=past_hours,
            delivery_area=delivery_area,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            with_order_details=with_order_details,
            contract_type=contract_type,
            with_portfolio_information=with_portfolio_information,
            with_risk_settings=with_risk_settings,
            with_products=with_products,
            active_only=active_only,
            with_auction_positions=with_auction_positions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBooks",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_books_without_preload_content(
        self,
        portfolio_id: Annotated[Optional[List[StrictStr]], Field(description="Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book.  **Note**: you must set this parameter if you want to see shadow trading changes applied.")] = None,
        product: Annotated[Optional[StrictStr], Field(description="DEPRECATED, use `products` instead. The list of products (e.g. Intraday_Power_D,XBID_Hour_Power) *separated by a comma*, for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks")] = None,
        products: Annotated[Optional[List[StrictStr]], Field(description="The list of products (e.g. Intraday_Power_D,XBID_Hour_Power), for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks")] = None,
        with_bid_or_ask_only: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask")] = None,
        with_signals: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain the signals applicable for the contracts")] = None,
        contract_id: Annotated[Optional[List[StrictStr]], Field(description="limit the orderbook to an array of certain contracts only")] = None,
        contract_name: Annotated[Optional[StrictStr], Field(description="limit the orderbook to a certain contract name only")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts with the given delivery start date")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts with the given delivery end date")] = None,
        delivery_within: Annotated[Optional[datetime], Field(description="limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter")] = None,
        past_hours: Annotated[Optional[Annotated[int, Field(le=24, strict=True, ge=0)]], Field(description="DEPRECATED: Please use `delivery_from` in combination with `active_only=false`. The number of hours to look into the past in the orderbook. If this parameter is set, historic closed contracts are contained in the orderbook as well. Cannot be used in conjunction with delivery_from.")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="The EIC of the delivery area of the orderbook")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limits the orderbook to those contracts with a delivery start date >= delivery_from. Cannot be used in conjunction with past_hours.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limits the orderbook to those contracts with a delivery end date <= delivery_to.")] = None,
        with_order_details: Annotated[Optional[StrictBool], Field(description="If set to true, the returned orderbook will contain all current bids and asks of each contract (full orderbook depth). *Heads up* We generally recommend to request the full orderbook depth on a per contract basis when orderbook-changed notifications are received via websocket. If you need the full orderbook depth for all contracts at once more frequently, please consider using full orderbook snapshots via websocket.")] = None,
        contract_type: Annotated[Optional[ContractType], Field(description="**PDC**: (default) the order book only includes predefined contracts, i.e. the normal contracts generated by the backend  UDC: the order book only includes block products, which were created as the result of a block order submitted by a member  ALL: the order book contains both, PDC and UDC contracts")] = None,
        with_portfolio_information: Annotated[Optional[StrictBool], Field(description="If set to true, the portfolio_information is included in the response.")] = None,
        with_risk_settings: Annotated[Optional[StrictBool], Field(description="If set to true, the risk_setting of the portfolio are included in the response.")] = None,
        with_products: Annotated[Optional[StrictBool], Field(description="If set to true, the available products are included in the response.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Setting this to false will also return order books for expired/inactive contracts.")] = None,
        with_auction_positions: Annotated[Optional[StrictBool], Field(description="If set to true, the auction positions are included in the response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all orderbooks

        Shows the public order book for the requested products (or all available products) for a given delivery_area. Default delivery area will be applied if left blank and default is set. This request will by default only deliver the order book statistics (best bid, best ask, last etc.) and does not include the full orderbook depth. If you wish to retrieve the full order book you can set with_order_details to \"true\". However, this should only be done if absolutely necessary, as it will negatively impact the performance. Alternatively you can request the full order book with GET /contract/contract_id/delivery_area/orders.  The order book contains portfolio relevant data (like net_position, signals etc.) and can thus be filtered by a list of portfolio IDs. Setting the limit parameter allows to limit the number of entries returned per request (sorted by ascending delivery time).  The filter with_bid_or_ask_only returns only non empty order books. If past_hours is set, the orderbook will include historical contracts that have been closed in the last X hours.  Using delivery_from and delivery_to, the order book can be further limited to a given timespan.

        :param portfolio_id: Providing a portfolio ID that corresponds with a shadow trading portfolio will result in the application of order book changes according to shadow trades made with the given portfolio. Shadow orders will also be added to the respective side of the order book.  **Note**: you must set this parameter if you want to see shadow trading changes applied.
        :type portfolio_id: List[str]
        :param product: DEPRECATED, use `products` instead. The list of products (e.g. Intraday_Power_D,XBID_Hour_Power) *separated by a comma*, for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks
        :type product: str
        :param products: The list of products (e.g. Intraday_Power_D,XBID_Hour_Power), for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks
        :type products: List[str]
        :param with_bid_or_ask_only: If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask
        :type with_bid_or_ask_only: bool
        :param with_signals: If set to true, the returned orderbook will contain the signals applicable for the contracts
        :type with_signals: bool
        :param contract_id: limit the orderbook to an array of certain contracts only
        :type contract_id: List[str]
        :param contract_name: limit the orderbook to a certain contract name only
        :type contract_name: str
        :param delivery_start: limit the orderbook to those contracts with the given delivery start date
        :type delivery_start: datetime
        :param delivery_end: limit the orderbook to those contracts with the given delivery end date
        :type delivery_end: datetime
        :param delivery_within: limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter
        :type delivery_within: datetime
        :param past_hours: DEPRECATED: Please use `delivery_from` in combination with `active_only=false`. The number of hours to look into the past in the orderbook. If this parameter is set, historic closed contracts are contained in the orderbook as well. Cannot be used in conjunction with delivery_from.
        :type past_hours: int
        :param delivery_area: The EIC of the delivery area of the orderbook
        :type delivery_area: str
        :param delivery_from: Limits the orderbook to those contracts with a delivery start date >= delivery_from. Cannot be used in conjunction with past_hours.
        :type delivery_from: datetime
        :param delivery_to: Limits the orderbook to those contracts with a delivery end date <= delivery_to.
        :type delivery_to: datetime
        :param with_order_details: If set to true, the returned orderbook will contain all current bids and asks of each contract (full orderbook depth). *Heads up* We generally recommend to request the full orderbook depth on a per contract basis when orderbook-changed notifications are received via websocket. If you need the full orderbook depth for all contracts at once more frequently, please consider using full orderbook snapshots via websocket.
        :type with_order_details: bool
        :param contract_type: **PDC**: (default) the order book only includes predefined contracts, i.e. the normal contracts generated by the backend  UDC: the order book only includes block products, which were created as the result of a block order submitted by a member  ALL: the order book contains both, PDC and UDC contracts
        :type contract_type: ContractType
        :param with_portfolio_information: If set to true, the portfolio_information is included in the response.
        :type with_portfolio_information: bool
        :param with_risk_settings: If set to true, the risk_setting of the portfolio are included in the response.
        :type with_risk_settings: bool
        :param with_products: If set to true, the available products are included in the response.
        :type with_products: bool
        :param active_only: Setting this to false will also return order books for expired/inactive contracts.
        :type active_only: bool
        :param with_auction_positions: If set to true, the auction positions are included in the response.
        :type with_auction_positions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_books_serialize(
            portfolio_id=portfolio_id,
            product=product,
            products=products,
            with_bid_or_ask_only=with_bid_or_ask_only,
            with_signals=with_signals,
            contract_id=contract_id,
            contract_name=contract_name,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_within=delivery_within,
            past_hours=past_hours,
            delivery_area=delivery_area,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            with_order_details=with_order_details,
            contract_type=contract_type,
            with_portfolio_information=with_portfolio_information,
            with_risk_settings=with_risk_settings,
            with_products=with_products,
            active_only=active_only,
            with_auction_positions=with_auction_positions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBooks",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_books_serialize(
        self,
        portfolio_id,
        product,
        products,
        with_bid_or_ask_only,
        with_signals,
        contract_id,
        contract_name,
        delivery_start,
        delivery_end,
        delivery_within,
        past_hours,
        delivery_area,
        delivery_from,
        delivery_to,
        with_order_details,
        contract_type,
        with_portfolio_information,
        with_risk_settings,
        with_products,
        active_only,
        with_auction_positions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'portfolio_id': 'csv',
            'products': 'multi',
            'contractId': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if product is not None:
            
            _query_params.append(('product', product))
            
        if products is not None:
            
            _query_params.append(('products', products))
            
        if with_bid_or_ask_only is not None:
            
            _query_params.append(('with_bid_or_ask_only', with_bid_or_ask_only))
            
        if with_signals is not None:
            
            _query_params.append(('with_signals', with_signals))
            
        if contract_id is not None:
            
            _query_params.append(('contractId', contract_id))
            
        if contract_name is not None:
            
            _query_params.append(('contractName', contract_name))
            
        if delivery_start is not None:
            if isinstance(delivery_start, datetime):
                _query_params.append(
                    (
                        'delivery_start',
                        delivery_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_start', delivery_start))
            
        if delivery_end is not None:
            if isinstance(delivery_end, datetime):
                _query_params.append(
                    (
                        'delivery_end',
                        delivery_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_end', delivery_end))
            
        if delivery_within is not None:
            if isinstance(delivery_within, datetime):
                _query_params.append(
                    (
                        'delivery_within',
                        delivery_within.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_within', delivery_within))
            
        if past_hours is not None:
            
            _query_params.append(('past_hours', past_hours))
            
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        if with_order_details is not None:
            
            _query_params.append(('with_order_details', with_order_details))
            
        if contract_type is not None:
            
            _query_params.append(('contract_type', contract_type.value))
            
        if with_portfolio_information is not None:
            
            _query_params.append(('with_portfolio_information', with_portfolio_information))
            
        if with_risk_settings is not None:
            
            _query_params.append(('with_risk_settings', with_risk_settings))
            
        if with_products is not None:
            
            _query_params.append(('with_products', with_products))
            
        if active_only is not None:
            
            _query_params.append(('active_only', active_only))
            
        if with_auction_positions is not None:
            
            _query_params.append(('with_auction_positions', with_auction_positions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/orderbooks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_orders(
        self,
        contract_id: StrictStr,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Annotated[Optional[StrictStr], Field(description="An optional parameter that can be used by tenants with shadow trading portfolios. If the provided portfolio ID corresponds with a shadow trading portfolio, the order book changes resulting from shadow trading will be applied to the returned orders list.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Orders:
        """Get contract full depth orderbook

        This method allows you to retrieve the full public orderbook of a contract (all bids and asks) in a specific delivery area.

        :param contract_id: (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id: An optional parameter that can be used by tenants with shadow trading portfolios. If the provided portfolio ID corresponds with a shadow trading portfolio, the order book changes resulting from shadow trading will be applied to the returned orders list.
        :type portfolio_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_orders_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_orders_with_http_info(
        self,
        contract_id: StrictStr,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Annotated[Optional[StrictStr], Field(description="An optional parameter that can be used by tenants with shadow trading portfolios. If the provided portfolio ID corresponds with a shadow trading portfolio, the order book changes resulting from shadow trading will be applied to the returned orders list.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Orders]:
        """Get contract full depth orderbook

        This method allows you to retrieve the full public orderbook of a contract (all bids and asks) in a specific delivery area.

        :param contract_id: (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id: An optional parameter that can be used by tenants with shadow trading portfolios. If the provided portfolio ID corresponds with a shadow trading portfolio, the order book changes resulting from shadow trading will be applied to the returned orders list.
        :type portfolio_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_orders_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_orders_without_preload_content(
        self,
        contract_id: StrictStr,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        portfolio_id: Annotated[Optional[StrictStr], Field(description="An optional parameter that can be used by tenants with shadow trading portfolios. If the provided portfolio ID corresponds with a shadow trading portfolio, the order book changes resulting from shadow trading will be applied to the returned orders list.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get contract full depth orderbook

        This method allows you to retrieve the full public orderbook of a contract (all bids and asks) in a specific delivery area.

        :param contract_id: (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param portfolio_id: An optional parameter that can be used by tenants with shadow trading portfolios. If the provided portfolio ID corresponds with a shadow trading portfolio, the order book changes resulting from shadow trading will be applied to the returned orders list.
        :type portfolio_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_orders_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_orders_serialize(
        self,
        contract_id,
        delivery_area,
        portfolio_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if contract_id is not None:
            _path_params['contract_id'] = contract_id
        if delivery_area is not None:
            _path_params['delivery_area'] = delivery_area
        # process the query parameters
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contract/{contract_id}/{delivery_area}/orders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_public_trades(
        self,
        contract_id: StrictStr,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        from_api_timestamp: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=)")] = None,
        to_api_timestamp: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <)")] = None,
        from_execution_time: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=)")] = None,
        to_execution_time: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PublicTrade]:
        """Get contract public trades

        This method allows you to retrieve all public trades that were executed at the exchange for a given contract_id and delivery area. Please note that this function uses pagination.

        :param contract_id: (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param from_api_timestamp: from timestamp is 'inclusive' (i.e. >=)
        :type from_api_timestamp: datetime
        :param to_api_timestamp: to timestamp is 'exclusive' (i.e. <)
        :type to_api_timestamp: datetime
        :param from_execution_time: from timestamp is 'inclusive' (i.e. >=)
        :type from_execution_time: datetime
        :param to_execution_time: to timestamp is 'exclusive' (i.e. <)
        :type to_execution_time: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_public_trades_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            offset=offset,
            limit=limit,
            from_api_timestamp=from_api_timestamp,
            to_api_timestamp=to_api_timestamp,
            from_execution_time=from_execution_time,
            to_execution_time=to_execution_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PublicTrade]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_public_trades_with_http_info(
        self,
        contract_id: StrictStr,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        from_api_timestamp: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=)")] = None,
        to_api_timestamp: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <)")] = None,
        from_execution_time: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=)")] = None,
        to_execution_time: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PublicTrade]]:
        """Get contract public trades

        This method allows you to retrieve all public trades that were executed at the exchange for a given contract_id and delivery area. Please note that this function uses pagination.

        :param contract_id: (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param from_api_timestamp: from timestamp is 'inclusive' (i.e. >=)
        :type from_api_timestamp: datetime
        :param to_api_timestamp: to timestamp is 'exclusive' (i.e. <)
        :type to_api_timestamp: datetime
        :param from_execution_time: from timestamp is 'inclusive' (i.e. >=)
        :type from_execution_time: datetime
        :param to_execution_time: to timestamp is 'exclusive' (i.e. <)
        :type to_execution_time: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_public_trades_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            offset=offset,
            limit=limit,
            from_api_timestamp=from_api_timestamp,
            to_api_timestamp=to_api_timestamp,
            from_execution_time=from_execution_time,
            to_execution_time=to_execution_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PublicTrade]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_public_trades_without_preload_content(
        self,
        contract_id: StrictStr,
        delivery_area: Annotated[StrictStr, Field(description="The EIC of the delivery area")],
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        from_api_timestamp: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=)")] = None,
        to_api_timestamp: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <)")] = None,
        from_execution_time: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=)")] = None,
        to_execution_time: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get contract public trades

        This method allows you to retrieve all public trades that were executed at the exchange for a given contract_id and delivery area. Please note that this function uses pagination.

        :param contract_id: (required)
        :type contract_id: str
        :param delivery_area: The EIC of the delivery area (required)
        :type delivery_area: str
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param from_api_timestamp: from timestamp is 'inclusive' (i.e. >=)
        :type from_api_timestamp: datetime
        :param to_api_timestamp: to timestamp is 'exclusive' (i.e. <)
        :type to_api_timestamp: datetime
        :param from_execution_time: from timestamp is 'inclusive' (i.e. >=)
        :type from_execution_time: datetime
        :param to_execution_time: to timestamp is 'exclusive' (i.e. <)
        :type to_execution_time: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_public_trades_serialize(
            contract_id=contract_id,
            delivery_area=delivery_area,
            offset=offset,
            limit=limit,
            from_api_timestamp=from_api_timestamp,
            to_api_timestamp=to_api_timestamp,
            from_execution_time=from_execution_time,
            to_execution_time=to_execution_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PublicTrade]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_public_trades_serialize(
        self,
        contract_id,
        delivery_area,
        offset,
        limit,
        from_api_timestamp,
        to_api_timestamp,
        from_execution_time,
        to_execution_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if contract_id is not None:
            _path_params['contract_id'] = contract_id
        if delivery_area is not None:
            _path_params['delivery_area'] = delivery_area
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if from_api_timestamp is not None:
            if isinstance(from_api_timestamp, datetime):
                _query_params.append(
                    (
                        'from_api_timestamp',
                        from_api_timestamp.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('from_api_timestamp', from_api_timestamp))
            
        if to_api_timestamp is not None:
            if isinstance(to_api_timestamp, datetime):
                _query_params.append(
                    (
                        'to_api_timestamp',
                        to_api_timestamp.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('to_api_timestamp', to_api_timestamp))
            
        if from_execution_time is not None:
            if isinstance(from_execution_time, datetime):
                _query_params.append(
                    (
                        'from_execution_time',
                        from_execution_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('from_execution_time', from_execution_time))
            
        if to_execution_time is not None:
            if isinstance(to_execution_time, datetime):
                _query_params.append(
                    (
                        'to_execution_time',
                        to_execution_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('to_execution_time', to_execution_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contract/{contract_id}/{delivery_area}/publictrades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


