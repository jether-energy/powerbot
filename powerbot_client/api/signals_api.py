# coding: utf-8

"""
    PowerBot - Webservice for algotrading

    # TERMS AND CONDITIONS The PowerBot system provides B2B services for trading at intraday power markets. By using the PowerBot service, each user agrees to the terms and conditions of this licence: 1. The user confirms that they are familiar with the exchanges trading system and all relevant rules, is professionally qualified and in possession of a trading license for the relevant exchange. 2. The user will comply with the exchanges market rules (e.g. [EPEX Spot Market Rules](https://www.epexspot.com/en/downloads#rules-fees-processes) or [Nord Pool Market Rules](https://www.nordpoolgroup.com/trading/Rules-and-regulations/)) and will not endanger the exchange system at any time with heavy load from trading algorithms or by other use. 3. The user is aware of limits imposed by the exchange. 4. The user is solely liable for actions resulting from the use of PowerBot.   # INTRODUCTION PowerBot is a web-based software service enabling algorithmic trading on intraday power exchanges such as EPEX, Nord Pool, HUPX, BSP Southpool, TGE, OPCOM or ETPA. The service is straightforward to integrate in an existing software environment and provides a variety of programming interfaces for development of individual trading algorithms and software tools. Besides enabling fully automated intraday trading, it can be used to create tools for human traders providing relevant information and trading opportunities or can be integrated in existing software tools. For further details see https://www.powerbot-trading.com  ## Knowledge Base In addition to this API guide, please find the documentation at https://docs.powerbot-trading.com - the password will be provided by the PowerBot team. If not, please reach out to us at support@powerbot-trading.com  ## Endpoints The PowerBot service is available at the following REST endpoints:  | Instance      | Base URL for REST Endpoints                                      | |---------------|------------------------------------------------------------------| | EPEX          | https://staging.powerbot-trading.com/playground/epex/v2/api      | | Nord Pool     | https://staging.powerbot-trading.com/playground/nordpool/v2/api  | | HUPX          | https://staging.powerbot-trading.com/playground/hupx/v2/api      | | BSP Southpool | https://staging.powerbot-trading.com/playground/southpool/v2/api | | TGE           | https://staging.powerbot-trading.com/playground/tge/v2/api       | | IBEX          | https://staging.powerbot-trading.com/playground/ibex/v2/api      | | CROPEX        | https://staging.powerbot-trading.com/playground/cropex/v2/api    | | OPCOM         | https://staging.powerbot-trading.com/playground/opcom/v2/api     | | ETPA          | https://staging.powerbot-trading.com/playground/etpa/v2/api      | | BRM           | https://staging.powerbot-trading.com/playground/brm/v2/api       |  Access to endpoints is secured via an API Key, which needs to be passed as an \"api_key\" header in each request.   Notes on API Keys:  * API keys are specific to Test, Staging or Production.  * API keys are generated by the system administrator and need to be requested.  ## How to generate API clients (libraries) This OpenAPI specification can be used to generate API clients (programming libraries) for a wide range of programming languages using tools like [OpenAPI Generator](https://openapi-generator.tech/). A detailed guide can be found in the [knowledge base](https://docs.powerbot-trading.com/articles/getting-started/generating-clients/).  ## PowerBot Python client For Python, a ready-made client is also available on PyPI and can be downloaded locally via:  ```shell   pip install powerbot-client ```  ## Errors The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be in JSON format as follows:  ``` {   \"message\": \"... an error message ...\" } ```  ## Paging The API uses offset and limit parameters for paged operations. An X-Total-Count header is added to responses to indicate the total number of items in a paged response.  ## Cross-Origin Resource Sharing This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with  [W3C spec](https://www.w3.org/TR/cors/). This allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site.  ## API Rate Limiting The API limits the number of concurrent calls to 50 - when that limit is reached, the client will receive 503 http status codes (service unavailable) with the following text:  ``` {   \"message\": \"API rate limit exceeded\" } ``` Clients should ensure that they stay within the limit for concurrent API calls.    ## Additional code samples Additional information and code samples demonstrating the use of the API can be found at in our [knowledge base](https://docs.powerbot-trading.com/docs/programmatic-access/)

    The version of the OpenAPI document: 2.16.1
    Contact: office@powerbot-trading.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from powerbot_client.models.bulk_signal import BulkSignal
from powerbot_client.models.bulk_signal_response import BulkSignalResponse
from powerbot_client.models.signal import Signal
from powerbot_client.models.signal_entry import SignalEntry
from powerbot_client.models.signal_entry_response import SignalEntryResponse
from powerbot_client.models.signal_search_result import SignalSearchResult
from powerbot_client.models.signal_source_durations import SignalSourceDurations

from powerbot_client.api_client import ApiClient, RequestSerialized
from powerbot_client.api_response import ApiResponse
from powerbot_client.rest import RESTResponseType


class SignalsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_signals(
        self,
        source: StrictStr,
        delivery_start: datetime,
        delivery_end: datetime,
        delivery_areas: Optional[List[StrictStr]] = None,
        portfolio_id: Optional[List[StrictStr]] = None,
        exact: Annotated[Optional[StrictBool], Field(description="only delete signals matching `delivery_start` and `delivery_end` exactly")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) Delete signals

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to delete signals. By setting the optional delivery_areas and/or portfolio_ids parameters, you can delete signals for selected cases only. Without specifying these parameters, the signal is removed completely. **Heads up** The \"source\" of a signal containing position_long and position_short is always \"POSITION\".

        :param source: (required)
        :type source: str
        :param delivery_start: (required)
        :type delivery_start: datetime
        :param delivery_end: (required)
        :type delivery_end: datetime
        :param delivery_areas:
        :type delivery_areas: List[str]
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param exact: only delete signals matching `delivery_start` and `delivery_end` exactly
        :type exact: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /signals/{source}/{delivery_start}/{delivery_end} is deprecated.", DeprecationWarning)

        _param = self._delete_signals_serialize(
            source=source,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_areas=delivery_areas,
            portfolio_id=portfolio_id,
            exact=exact,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_signals_with_http_info(
        self,
        source: StrictStr,
        delivery_start: datetime,
        delivery_end: datetime,
        delivery_areas: Optional[List[StrictStr]] = None,
        portfolio_id: Optional[List[StrictStr]] = None,
        exact: Annotated[Optional[StrictBool], Field(description="only delete signals matching `delivery_start` and `delivery_end` exactly")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) Delete signals

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to delete signals. By setting the optional delivery_areas and/or portfolio_ids parameters, you can delete signals for selected cases only. Without specifying these parameters, the signal is removed completely. **Heads up** The \"source\" of a signal containing position_long and position_short is always \"POSITION\".

        :param source: (required)
        :type source: str
        :param delivery_start: (required)
        :type delivery_start: datetime
        :param delivery_end: (required)
        :type delivery_end: datetime
        :param delivery_areas:
        :type delivery_areas: List[str]
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param exact: only delete signals matching `delivery_start` and `delivery_end` exactly
        :type exact: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /signals/{source}/{delivery_start}/{delivery_end} is deprecated.", DeprecationWarning)

        _param = self._delete_signals_serialize(
            source=source,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_areas=delivery_areas,
            portfolio_id=portfolio_id,
            exact=exact,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_signals_without_preload_content(
        self,
        source: StrictStr,
        delivery_start: datetime,
        delivery_end: datetime,
        delivery_areas: Optional[List[StrictStr]] = None,
        portfolio_id: Optional[List[StrictStr]] = None,
        exact: Annotated[Optional[StrictBool], Field(description="only delete signals matching `delivery_start` and `delivery_end` exactly")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Delete signals

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to delete signals. By setting the optional delivery_areas and/or portfolio_ids parameters, you can delete signals for selected cases only. Without specifying these parameters, the signal is removed completely. **Heads up** The \"source\" of a signal containing position_long and position_short is always \"POSITION\".

        :param source: (required)
        :type source: str
        :param delivery_start: (required)
        :type delivery_start: datetime
        :param delivery_end: (required)
        :type delivery_end: datetime
        :param delivery_areas:
        :type delivery_areas: List[str]
        :param portfolio_id:
        :type portfolio_id: List[str]
        :param exact: only delete signals matching `delivery_start` and `delivery_end` exactly
        :type exact: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /signals/{source}/{delivery_start}/{delivery_end} is deprecated.", DeprecationWarning)

        _param = self._delete_signals_serialize(
            source=source,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_areas=delivery_areas,
            portfolio_id=portfolio_id,
            exact=exact,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_signals_serialize(
        self,
        source,
        delivery_start,
        delivery_end,
        delivery_areas,
        portfolio_id,
        exact,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'delivery_areas': 'csv',
            'portfolio_id': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source is not None:
            _path_params['source'] = source
        if delivery_start is not None:
            _path_params['delivery_start'] = delivery_start
        if delivery_end is not None:
            _path_params['delivery_end'] = delivery_end
        # process the query parameters
        if delivery_areas is not None:
            
            _query_params.append(('delivery_areas', delivery_areas))
            
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if exact is not None:
            
            _query_params.append(('exact', exact))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/signals/{source}/{delivery_start}/{delivery_end}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_time_slice(
        self,
        source: Annotated[StrictStr, Field(description="The source of the signal")],
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the signal")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the signal")],
        delivery_start: Annotated[datetime, Field(description="The delivery start of the signal")],
        delivery_end: Annotated[datetime, Field(description="The delivery end of the signal")],
        minutes_to_delivery: Annotated[StrictInt, Field(description="The offset until delivery start")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a time slice

        Deletes a single time slice of a trading signal. Will not increase the revision of a time slice.

        :param source: The source of the signal (required)
        :type source: str
        :param delivery_area: The delivery area of the signal (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the signal (required)
        :type portfolio_id: str
        :param delivery_start: The delivery start of the signal (required)
        :type delivery_start: datetime
        :param delivery_end: The delivery end of the signal (required)
        :type delivery_end: datetime
        :param minutes_to_delivery: The offset until delivery start (required)
        :type minutes_to_delivery: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_time_slice_serialize(
            source=source,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            minutes_to_delivery=minutes_to_delivery,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_time_slice_with_http_info(
        self,
        source: Annotated[StrictStr, Field(description="The source of the signal")],
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the signal")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the signal")],
        delivery_start: Annotated[datetime, Field(description="The delivery start of the signal")],
        delivery_end: Annotated[datetime, Field(description="The delivery end of the signal")],
        minutes_to_delivery: Annotated[StrictInt, Field(description="The offset until delivery start")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a time slice

        Deletes a single time slice of a trading signal. Will not increase the revision of a time slice.

        :param source: The source of the signal (required)
        :type source: str
        :param delivery_area: The delivery area of the signal (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the signal (required)
        :type portfolio_id: str
        :param delivery_start: The delivery start of the signal (required)
        :type delivery_start: datetime
        :param delivery_end: The delivery end of the signal (required)
        :type delivery_end: datetime
        :param minutes_to_delivery: The offset until delivery start (required)
        :type minutes_to_delivery: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_time_slice_serialize(
            source=source,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            minutes_to_delivery=minutes_to_delivery,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_time_slice_without_preload_content(
        self,
        source: Annotated[StrictStr, Field(description="The source of the signal")],
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the signal")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the signal")],
        delivery_start: Annotated[datetime, Field(description="The delivery start of the signal")],
        delivery_end: Annotated[datetime, Field(description="The delivery end of the signal")],
        minutes_to_delivery: Annotated[StrictInt, Field(description="The offset until delivery start")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a time slice

        Deletes a single time slice of a trading signal. Will not increase the revision of a time slice.

        :param source: The source of the signal (required)
        :type source: str
        :param delivery_area: The delivery area of the signal (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the signal (required)
        :type portfolio_id: str
        :param delivery_start: The delivery start of the signal (required)
        :type delivery_start: datetime
        :param delivery_end: The delivery end of the signal (required)
        :type delivery_end: datetime
        :param minutes_to_delivery: The offset until delivery start (required)
        :type minutes_to_delivery: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_time_slice_serialize(
            source=source,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            minutes_to_delivery=minutes_to_delivery,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_time_slice_serialize(
        self,
        source,
        delivery_area,
        portfolio_id,
        delivery_start,
        delivery_end,
        minutes_to_delivery,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source is not None:
            _path_params['source'] = source
        if delivery_area is not None:
            _path_params['delivery_area'] = delivery_area
        if portfolio_id is not None:
            _path_params['portfolio_id'] = portfolio_id
        if delivery_start is not None:
            _path_params['delivery_start'] = delivery_start
        if delivery_end is not None:
            _path_params['delivery_end'] = delivery_end
        if minutes_to_delivery is not None:
            _path_params['minutes_to_delivery'] = minutes_to_delivery
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/trading-signal/{source}/{delivery_area}/{portfolio_id}/{delivery_start}/{delivery_end}/{minutes_to_delivery}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_trading_signal(
        self,
        source: Annotated[StrictStr, Field(description="The source of the signal")],
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the signal")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the signal")],
        delivery_start: Annotated[datetime, Field(description="The delivery start of the signal")],
        delivery_end: Annotated[datetime, Field(description="The delivery end of the signal")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a trading signal

        Delete a trading signal with all of its time slices, meaning all signals which have the same source, delivery area, portfolio ID and delivery period. Deletion will not increase the revision of a time slice.

        :param source: The source of the signal (required)
        :type source: str
        :param delivery_area: The delivery area of the signal (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the signal (required)
        :type portfolio_id: str
        :param delivery_start: The delivery start of the signal (required)
        :type delivery_start: datetime
        :param delivery_end: The delivery end of the signal (required)
        :type delivery_end: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_trading_signal_serialize(
            source=source,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_trading_signal_with_http_info(
        self,
        source: Annotated[StrictStr, Field(description="The source of the signal")],
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the signal")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the signal")],
        delivery_start: Annotated[datetime, Field(description="The delivery start of the signal")],
        delivery_end: Annotated[datetime, Field(description="The delivery end of the signal")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a trading signal

        Delete a trading signal with all of its time slices, meaning all signals which have the same source, delivery area, portfolio ID and delivery period. Deletion will not increase the revision of a time slice.

        :param source: The source of the signal (required)
        :type source: str
        :param delivery_area: The delivery area of the signal (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the signal (required)
        :type portfolio_id: str
        :param delivery_start: The delivery start of the signal (required)
        :type delivery_start: datetime
        :param delivery_end: The delivery end of the signal (required)
        :type delivery_end: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_trading_signal_serialize(
            source=source,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_trading_signal_without_preload_content(
        self,
        source: Annotated[StrictStr, Field(description="The source of the signal")],
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the signal")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the signal")],
        delivery_start: Annotated[datetime, Field(description="The delivery start of the signal")],
        delivery_end: Annotated[datetime, Field(description="The delivery end of the signal")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a trading signal

        Delete a trading signal with all of its time slices, meaning all signals which have the same source, delivery area, portfolio ID and delivery period. Deletion will not increase the revision of a time slice.

        :param source: The source of the signal (required)
        :type source: str
        :param delivery_area: The delivery area of the signal (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the signal (required)
        :type portfolio_id: str
        :param delivery_start: The delivery start of the signal (required)
        :type delivery_start: datetime
        :param delivery_end: The delivery end of the signal (required)
        :type delivery_end: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_trading_signal_serialize(
            source=source,
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_trading_signal_serialize(
        self,
        source,
        delivery_area,
        portfolio_id,
        delivery_start,
        delivery_end,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source is not None:
            _path_params['source'] = source
        if delivery_area is not None:
            _path_params['delivery_area'] = delivery_area
        if portfolio_id is not None:
            _path_params['portfolio_id'] = portfolio_id
        if delivery_start is not None:
            _path_params['delivery_start'] = delivery_start
        if delivery_end is not None:
            _path_params['delivery_end'] = delivery_end
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/trading-signal/{source}/{delivery_area}/{portfolio_id}/{delivery_start}/{delivery_end}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_trading_signals(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the trading signal.")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the trading signal.")],
        source: Annotated[Optional[StrictStr], Field(description="The source of the trading signal.")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="The 'delivery_start' of the signal in UTC. Has be used together with 'delivery_end' and cannot be combined with 'delivery_from' or 'delivery_to'.")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="The 'delivery_end' of the signal in UTC. Has be used together with 'delivery_start' and cannot be combined with 'delivery_from' or 'delivery_to'.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limit trading signals to those that have a 'delivery_start' greater or equal to the given value. Has be used together with 'delivery_to' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limit trading signals to those that have a delivery end less than or equal to the given value. Has be used together with 'delivery_from' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.")] = None,
        minutes_to_delivery_gte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.")] = None,
        minutes_to_delivery_lte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="The starting revision from 0")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="The ending revision (non-inclusive)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=150, strict=True, ge=1)]], Field(description="Limits the number of loaded items.")] = None,
        include_historic: Annotated[Optional[StrictBool], Field(description="Setting this to `true` will also return old (overwritten) signal revisions. Cannot be combined with `active_only=true`.")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Setting this to `true` will also return deleted time slices. Cannot be combined with `active_only=true`.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Filter for only currently active time slices. Cannot be combined with `include_historic=true`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignalSearchResult:
        """Find trading signals

        Retrieves trading signals based on the given filter criteria. This endpoint also provides historic signal data when the `include_historic` parameter is set to true. The response object will contain the list of all unique sources and the actual signals, grouped by their source, delivery area, portfolio ID and delivery period. Signals will be sorted in ascending order by the aforementioned parameters  time slices are in descending order based on their minutes to delivery. Note that you have to either specify 'delivery_start' and 'delivery_end' or 'delivery_from' and 'delivery_to'. The maximum timespan is limited to 48 hours.

        :param delivery_area: The delivery area of the trading signal. (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the trading signal. (required)
        :type portfolio_id: str
        :param source: The source of the trading signal.
        :type source: str
        :param delivery_start: The 'delivery_start' of the signal in UTC. Has be used together with 'delivery_end' and cannot be combined with 'delivery_from' or 'delivery_to'.
        :type delivery_start: datetime
        :param delivery_end: The 'delivery_end' of the signal in UTC. Has be used together with 'delivery_start' and cannot be combined with 'delivery_from' or 'delivery_to'.
        :type delivery_end: datetime
        :param delivery_from: Limit trading signals to those that have a 'delivery_start' greater or equal to the given value. Has be used together with 'delivery_to' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.
        :type delivery_from: datetime
        :param delivery_to: Limit trading signals to those that have a delivery end less than or equal to the given value. Has be used together with 'delivery_from' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.
        :type delivery_to: datetime
        :param minutes_to_delivery_gte: The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_gte: int
        :param minutes_to_delivery_lte: The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_lte: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param revision_from: The starting revision from 0
        :type revision_from: int
        :param revision_to: The ending revision (non-inclusive)
        :type revision_to: int
        :param offset: Offset when loading a list of items.
        :type offset: int
        :param limit: Limits the number of loaded items.
        :type limit: int
        :param include_historic: Setting this to `true` will also return old (overwritten) signal revisions. Cannot be combined with `active_only=true`.
        :type include_historic: bool
        :param include_deleted: Setting this to `true` will also return deleted time slices. Cannot be combined with `active_only=true`.
        :type include_deleted: bool
        :param active_only: Filter for only currently active time slices. Cannot be combined with `include_historic=true`.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_trading_signals_serialize(
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            source=source,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            minutes_to_delivery_gte=minutes_to_delivery_gte,
            minutes_to_delivery_lte=minutes_to_delivery_lte,
            received_from=received_from,
            received_to=received_to,
            revision_from=revision_from,
            revision_to=revision_to,
            offset=offset,
            limit=limit,
            include_historic=include_historic,
            include_deleted=include_deleted,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignalSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_trading_signals_with_http_info(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the trading signal.")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the trading signal.")],
        source: Annotated[Optional[StrictStr], Field(description="The source of the trading signal.")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="The 'delivery_start' of the signal in UTC. Has be used together with 'delivery_end' and cannot be combined with 'delivery_from' or 'delivery_to'.")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="The 'delivery_end' of the signal in UTC. Has be used together with 'delivery_start' and cannot be combined with 'delivery_from' or 'delivery_to'.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limit trading signals to those that have a 'delivery_start' greater or equal to the given value. Has be used together with 'delivery_to' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limit trading signals to those that have a delivery end less than or equal to the given value. Has be used together with 'delivery_from' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.")] = None,
        minutes_to_delivery_gte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.")] = None,
        minutes_to_delivery_lte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="The starting revision from 0")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="The ending revision (non-inclusive)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=150, strict=True, ge=1)]], Field(description="Limits the number of loaded items.")] = None,
        include_historic: Annotated[Optional[StrictBool], Field(description="Setting this to `true` will also return old (overwritten) signal revisions. Cannot be combined with `active_only=true`.")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Setting this to `true` will also return deleted time slices. Cannot be combined with `active_only=true`.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Filter for only currently active time slices. Cannot be combined with `include_historic=true`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignalSearchResult]:
        """Find trading signals

        Retrieves trading signals based on the given filter criteria. This endpoint also provides historic signal data when the `include_historic` parameter is set to true. The response object will contain the list of all unique sources and the actual signals, grouped by their source, delivery area, portfolio ID and delivery period. Signals will be sorted in ascending order by the aforementioned parameters  time slices are in descending order based on their minutes to delivery. Note that you have to either specify 'delivery_start' and 'delivery_end' or 'delivery_from' and 'delivery_to'. The maximum timespan is limited to 48 hours.

        :param delivery_area: The delivery area of the trading signal. (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the trading signal. (required)
        :type portfolio_id: str
        :param source: The source of the trading signal.
        :type source: str
        :param delivery_start: The 'delivery_start' of the signal in UTC. Has be used together with 'delivery_end' and cannot be combined with 'delivery_from' or 'delivery_to'.
        :type delivery_start: datetime
        :param delivery_end: The 'delivery_end' of the signal in UTC. Has be used together with 'delivery_start' and cannot be combined with 'delivery_from' or 'delivery_to'.
        :type delivery_end: datetime
        :param delivery_from: Limit trading signals to those that have a 'delivery_start' greater or equal to the given value. Has be used together with 'delivery_to' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.
        :type delivery_from: datetime
        :param delivery_to: Limit trading signals to those that have a delivery end less than or equal to the given value. Has be used together with 'delivery_from' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.
        :type delivery_to: datetime
        :param minutes_to_delivery_gte: The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_gte: int
        :param minutes_to_delivery_lte: The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_lte: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param revision_from: The starting revision from 0
        :type revision_from: int
        :param revision_to: The ending revision (non-inclusive)
        :type revision_to: int
        :param offset: Offset when loading a list of items.
        :type offset: int
        :param limit: Limits the number of loaded items.
        :type limit: int
        :param include_historic: Setting this to `true` will also return old (overwritten) signal revisions. Cannot be combined with `active_only=true`.
        :type include_historic: bool
        :param include_deleted: Setting this to `true` will also return deleted time slices. Cannot be combined with `active_only=true`.
        :type include_deleted: bool
        :param active_only: Filter for only currently active time slices. Cannot be combined with `include_historic=true`.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_trading_signals_serialize(
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            source=source,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            minutes_to_delivery_gte=minutes_to_delivery_gte,
            minutes_to_delivery_lte=minutes_to_delivery_lte,
            received_from=received_from,
            received_to=received_to,
            revision_from=revision_from,
            revision_to=revision_to,
            offset=offset,
            limit=limit,
            include_historic=include_historic,
            include_deleted=include_deleted,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignalSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_trading_signals_without_preload_content(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the trading signal.")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the trading signal.")],
        source: Annotated[Optional[StrictStr], Field(description="The source of the trading signal.")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="The 'delivery_start' of the signal in UTC. Has be used together with 'delivery_end' and cannot be combined with 'delivery_from' or 'delivery_to'.")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="The 'delivery_end' of the signal in UTC. Has be used together with 'delivery_start' and cannot be combined with 'delivery_from' or 'delivery_to'.")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="Limit trading signals to those that have a 'delivery_start' greater or equal to the given value. Has be used together with 'delivery_to' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="Limit trading signals to those that have a delivery end less than or equal to the given value. Has be used together with 'delivery_from' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.")] = None,
        minutes_to_delivery_gte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.")] = None,
        minutes_to_delivery_lte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="The starting revision from 0")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="The ending revision (non-inclusive)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=150, strict=True, ge=1)]], Field(description="Limits the number of loaded items.")] = None,
        include_historic: Annotated[Optional[StrictBool], Field(description="Setting this to `true` will also return old (overwritten) signal revisions. Cannot be combined with `active_only=true`.")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Setting this to `true` will also return deleted time slices. Cannot be combined with `active_only=true`.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Filter for only currently active time slices. Cannot be combined with `include_historic=true`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find trading signals

        Retrieves trading signals based on the given filter criteria. This endpoint also provides historic signal data when the `include_historic` parameter is set to true. The response object will contain the list of all unique sources and the actual signals, grouped by their source, delivery area, portfolio ID and delivery period. Signals will be sorted in ascending order by the aforementioned parameters  time slices are in descending order based on their minutes to delivery. Note that you have to either specify 'delivery_start' and 'delivery_end' or 'delivery_from' and 'delivery_to'. The maximum timespan is limited to 48 hours.

        :param delivery_area: The delivery area of the trading signal. (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the trading signal. (required)
        :type portfolio_id: str
        :param source: The source of the trading signal.
        :type source: str
        :param delivery_start: The 'delivery_start' of the signal in UTC. Has be used together with 'delivery_end' and cannot be combined with 'delivery_from' or 'delivery_to'.
        :type delivery_start: datetime
        :param delivery_end: The 'delivery_end' of the signal in UTC. Has be used together with 'delivery_start' and cannot be combined with 'delivery_from' or 'delivery_to'.
        :type delivery_end: datetime
        :param delivery_from: Limit trading signals to those that have a 'delivery_start' greater or equal to the given value. Has be used together with 'delivery_to' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.
        :type delivery_from: datetime
        :param delivery_to: Limit trading signals to those that have a delivery end less than or equal to the given value. Has be used together with 'delivery_from' and cannot be combined with 'delivery_start' or 'delivery_end'. The maximum timespan is limited to 48 hours.
        :type delivery_to: datetime
        :param minutes_to_delivery_gte: The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_gte: int
        :param minutes_to_delivery_lte: The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_lte: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param revision_from: The starting revision from 0
        :type revision_from: int
        :param revision_to: The ending revision (non-inclusive)
        :type revision_to: int
        :param offset: Offset when loading a list of items.
        :type offset: int
        :param limit: Limits the number of loaded items.
        :type limit: int
        :param include_historic: Setting this to `true` will also return old (overwritten) signal revisions. Cannot be combined with `active_only=true`.
        :type include_historic: bool
        :param include_deleted: Setting this to `true` will also return deleted time slices. Cannot be combined with `active_only=true`.
        :type include_deleted: bool
        :param active_only: Filter for only currently active time slices. Cannot be combined with `include_historic=true`.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_trading_signals_serialize(
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            source=source,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            minutes_to_delivery_gte=minutes_to_delivery_gte,
            minutes_to_delivery_lte=minutes_to_delivery_lte,
            received_from=received_from,
            received_to=received_to,
            revision_from=revision_from,
            revision_to=revision_to,
            offset=offset,
            limit=limit,
            include_historic=include_historic,
            include_deleted=include_deleted,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignalSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_trading_signals_serialize(
        self,
        delivery_area,
        portfolio_id,
        source,
        delivery_start,
        delivery_end,
        delivery_from,
        delivery_to,
        minutes_to_delivery_gte,
        minutes_to_delivery_lte,
        received_from,
        received_to,
        revision_from,
        revision_to,
        offset,
        limit,
        include_historic,
        include_deleted,
        active_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if source is not None:
            
            _query_params.append(('source', source))
            
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if delivery_start is not None:
            if isinstance(delivery_start, datetime):
                _query_params.append(
                    (
                        'delivery_start',
                        delivery_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_start', delivery_start))
            
        if delivery_end is not None:
            if isinstance(delivery_end, datetime):
                _query_params.append(
                    (
                        'delivery_end',
                        delivery_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_end', delivery_end))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        if minutes_to_delivery_gte is not None:
            
            _query_params.append(('minutes_to_delivery_gte', minutes_to_delivery_gte))
            
        if minutes_to_delivery_lte is not None:
            
            _query_params.append(('minutes_to_delivery_lte', minutes_to_delivery_lte))
            
        if received_from is not None:
            if isinstance(received_from, datetime):
                _query_params.append(
                    (
                        'received_from',
                        received_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_from', received_from))
            
        if received_to is not None:
            if isinstance(received_to, datetime):
                _query_params.append(
                    (
                        'received_to',
                        received_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_to', received_to))
            
        if revision_from is not None:
            
            _query_params.append(('revision_from', revision_from))
            
        if revision_to is not None:
            
            _query_params.append(('revision_to', revision_to))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include_historic is not None:
            
            _query_params.append(('include_historic', include_historic))
            
        if include_deleted is not None:
            
            _query_params.append(('include_deleted', include_deleted))
            
        if active_only is not None:
            
            _query_params.append(('active_only', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/trading-signals',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_signals(
        self,
        portfolio_id: Optional[List[StrictStr]] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="filter by delivery area")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Signal]:
        """(Deprecated) List signals

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to retrieve signals you have previously sent to the system.

        :param portfolio_id:
        :type portfolio_id: List[str]
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param delivery_area: filter by delivery area
        :type delivery_area: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /signals is deprecated.", DeprecationWarning)

        _param = self._get_signals_serialize(
            portfolio_id=portfolio_id,
            offset=offset,
            limit=limit,
            received_from=received_from,
            received_to=received_to,
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_signals_with_http_info(
        self,
        portfolio_id: Optional[List[StrictStr]] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="filter by delivery area")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Signal]]:
        """(Deprecated) List signals

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to retrieve signals you have previously sent to the system.

        :param portfolio_id:
        :type portfolio_id: List[str]
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param delivery_area: filter by delivery area
        :type delivery_area: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /signals is deprecated.", DeprecationWarning)

        _param = self._get_signals_serialize(
            portfolio_id=portfolio_id,
            offset=offset,
            limit=limit,
            received_from=received_from,
            received_to=received_to,
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_signals_without_preload_content(
        self,
        portfolio_id: Optional[List[StrictStr]] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="filter by delivery area")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) List signals

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to retrieve signals you have previously sent to the system.

        :param portfolio_id:
        :type portfolio_id: List[str]
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param delivery_area: filter by delivery area
        :type delivery_area: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /signals is deprecated.", DeprecationWarning)

        _param = self._get_signals_serialize(
            portfolio_id=portfolio_id,
            offset=offset,
            limit=limit,
            received_from=received_from,
            received_to=received_to,
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_signals_serialize(
        self,
        portfolio_id,
        offset,
        limit,
        received_from,
        received_to,
        delivery_area,
        delivery_start,
        delivery_end,
        delivery_from,
        delivery_to,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'portfolio_id': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if received_from is not None:
            if isinstance(received_from, datetime):
                _query_params.append(
                    (
                        'received_from',
                        received_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_from', received_from))
            
        if received_to is not None:
            if isinstance(received_to, datetime):
                _query_params.append(
                    (
                        'received_to',
                        received_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_to', received_to))
            
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if delivery_start is not None:
            if isinstance(delivery_start, datetime):
                _query_params.append(
                    (
                        'delivery_start',
                        delivery_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_start', delivery_start))
            
        if delivery_end is not None:
            if isinstance(delivery_end, datetime):
                _query_params.append(
                    (
                        'delivery_end',
                        delivery_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_end', delivery_end))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/signals',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_signals_history(
        self,
        portfolio_id: Optional[List[StrictStr]] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="filter by delivery area")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        source: Annotated[Optional[StrictStr], Field(description="filter by signal source")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="limit to revisions greater or equal to the given value")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="limit to revisions greater or equal to the given value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Signal]:
        """(Deprecated) List signals history

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to retrieve the signal history.

        :param portfolio_id:
        :type portfolio_id: List[str]
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param delivery_area: filter by delivery area
        :type delivery_area: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param source: filter by signal source
        :type source: str
        :param revision_from: limit to revisions greater or equal to the given value
        :type revision_from: int
        :param revision_to: limit to revisions greater or equal to the given value
        :type revision_to: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /signals/history is deprecated.", DeprecationWarning)

        _param = self._get_signals_history_serialize(
            portfolio_id=portfolio_id,
            offset=offset,
            limit=limit,
            received_from=received_from,
            received_to=received_to,
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            source=source,
            revision_from=revision_from,
            revision_to=revision_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_signals_history_with_http_info(
        self,
        portfolio_id: Optional[List[StrictStr]] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="filter by delivery area")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        source: Annotated[Optional[StrictStr], Field(description="filter by signal source")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="limit to revisions greater or equal to the given value")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="limit to revisions greater or equal to the given value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Signal]]:
        """(Deprecated) List signals history

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to retrieve the signal history.

        :param portfolio_id:
        :type portfolio_id: List[str]
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param delivery_area: filter by delivery area
        :type delivery_area: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param source: filter by signal source
        :type source: str
        :param revision_from: limit to revisions greater or equal to the given value
        :type revision_from: int
        :param revision_to: limit to revisions greater or equal to the given value
        :type revision_to: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /signals/history is deprecated.", DeprecationWarning)

        _param = self._get_signals_history_serialize(
            portfolio_id=portfolio_id,
            offset=offset,
            limit=limit,
            received_from=received_from,
            received_to=received_to,
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            source=source,
            revision_from=revision_from,
            revision_to=revision_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_signals_history_without_preload_content(
        self,
        portfolio_id: Optional[List[StrictStr]] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset when loading a list of items")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Limits the number of loaded items")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        delivery_area: Annotated[Optional[StrictStr], Field(description="filter by delivery area")] = None,
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        source: Annotated[Optional[StrictStr], Field(description="filter by signal source")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="limit to revisions greater or equal to the given value")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="limit to revisions greater or equal to the given value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) List signals history

        DEPRECATED. Signals are replaced by Trading Signals. Allows you to retrieve the signal history.

        :param portfolio_id:
        :type portfolio_id: List[str]
        :param offset: Offset when loading a list of items
        :type offset: int
        :param limit: Limits the number of loaded items
        :type limit: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param delivery_area: filter by delivery area
        :type delivery_area: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param source: filter by signal source
        :type source: str
        :param revision_from: limit to revisions greater or equal to the given value
        :type revision_from: int
        :param revision_to: limit to revisions greater or equal to the given value
        :type revision_to: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /signals/history is deprecated.", DeprecationWarning)

        _param = self._get_signals_history_serialize(
            portfolio_id=portfolio_id,
            offset=offset,
            limit=limit,
            received_from=received_from,
            received_to=received_to,
            delivery_area=delivery_area,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            source=source,
            revision_from=revision_from,
            revision_to=revision_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Signal]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_signals_history_serialize(
        self,
        portfolio_id,
        offset,
        limit,
        received_from,
        received_to,
        delivery_area,
        delivery_start,
        delivery_end,
        delivery_from,
        delivery_to,
        source,
        revision_from,
        revision_to,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'portfolio_id': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if received_from is not None:
            if isinstance(received_from, datetime):
                _query_params.append(
                    (
                        'received_from',
                        received_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_from', received_from))
            
        if received_to is not None:
            if isinstance(received_to, datetime):
                _query_params.append(
                    (
                        'received_to',
                        received_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_to', received_to))
            
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if delivery_start is not None:
            if isinstance(delivery_start, datetime):
                _query_params.append(
                    (
                        'delivery_start',
                        delivery_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_start', delivery_start))
            
        if delivery_end is not None:
            if isinstance(delivery_end, datetime):
                _query_params.append(
                    (
                        'delivery_end',
                        delivery_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_end', delivery_end))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        if source is not None:
            
            _query_params.append(('source', source))
            
        if revision_from is not None:
            
            _query_params.append(('revision_from', revision_from))
            
        if revision_to is not None:
            
            _query_params.append(('revision_to', revision_to))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/signals/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_sources_durations(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the trading signal.")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the trading signal.")],
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        minutes_to_delivery_gte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.")] = None,
        minutes_to_delivery_lte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="The starting revision from 0")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="The ending revision (non-inclusive)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SignalSourceDurations]:
        """Get sources and durations

        Retrieves all unique sources and durations of a trading signals delivery period. Note that you have to either specify 'delivery_start' and 'delivery_end' or 'delivery_from' and 'delivery_to'. The maximum timespan is limited to 48 hours.

        :param delivery_area: The delivery area of the trading signal. (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the trading signal. (required)
        :type portfolio_id: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param minutes_to_delivery_gte: The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_gte: int
        :param minutes_to_delivery_lte: The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_lte: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param revision_from: The starting revision from 0
        :type revision_from: int
        :param revision_to: The ending revision (non-inclusive)
        :type revision_to: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_durations_serialize(
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            minutes_to_delivery_gte=minutes_to_delivery_gte,
            minutes_to_delivery_lte=minutes_to_delivery_lte,
            received_from=received_from,
            received_to=received_to,
            revision_from=revision_from,
            revision_to=revision_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SignalSourceDurations]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_sources_durations_with_http_info(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the trading signal.")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the trading signal.")],
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        minutes_to_delivery_gte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.")] = None,
        minutes_to_delivery_lte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="The starting revision from 0")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="The ending revision (non-inclusive)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SignalSourceDurations]]:
        """Get sources and durations

        Retrieves all unique sources and durations of a trading signals delivery period. Note that you have to either specify 'delivery_start' and 'delivery_end' or 'delivery_from' and 'delivery_to'. The maximum timespan is limited to 48 hours.

        :param delivery_area: The delivery area of the trading signal. (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the trading signal. (required)
        :type portfolio_id: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param minutes_to_delivery_gte: The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_gte: int
        :param minutes_to_delivery_lte: The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_lte: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param revision_from: The starting revision from 0
        :type revision_from: int
        :param revision_to: The ending revision (non-inclusive)
        :type revision_to: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_durations_serialize(
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            minutes_to_delivery_gte=minutes_to_delivery_gte,
            minutes_to_delivery_lte=minutes_to_delivery_lte,
            received_from=received_from,
            received_to=received_to,
            revision_from=revision_from,
            revision_to=revision_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SignalSourceDurations]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_sources_durations_without_preload_content(
        self,
        delivery_area: Annotated[StrictStr, Field(description="The delivery area of the trading signal.")],
        portfolio_id: Annotated[StrictStr, Field(description="The portfolio ID of the trading signal.")],
        delivery_start: Annotated[Optional[datetime], Field(description="filter by delivery_start, use UTC timezone")] = None,
        delivery_end: Annotated[Optional[datetime], Field(description="filter by delivery_end, use UTC timezone")] = None,
        delivery_from: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery start greater or equal to the given value")] = None,
        delivery_to: Annotated[Optional[datetime], Field(description="limit signals to those that have a delivery end less than or equal to the given value")] = None,
        minutes_to_delivery_gte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.")] = None,
        minutes_to_delivery_lte: Annotated[Optional[StrictInt], Field(description="The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.")] = None,
        received_from: Annotated[Optional[datetime], Field(description="from timestamp is 'inclusive' (i.e. >=), use UTC timezone")] = None,
        received_to: Annotated[Optional[datetime], Field(description="to timestamp is 'exclusive' (i.e. <), use UTC timezone")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="The starting revision from 0")] = None,
        revision_to: Annotated[Optional[StrictInt], Field(description="The ending revision (non-inclusive)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get sources and durations

        Retrieves all unique sources and durations of a trading signals delivery period. Note that you have to either specify 'delivery_start' and 'delivery_end' or 'delivery_from' and 'delivery_to'. The maximum timespan is limited to 48 hours.

        :param delivery_area: The delivery area of the trading signal. (required)
        :type delivery_area: str
        :param portfolio_id: The portfolio ID of the trading signal. (required)
        :type portfolio_id: str
        :param delivery_start: filter by delivery_start, use UTC timezone
        :type delivery_start: datetime
        :param delivery_end: filter by delivery_end, use UTC timezone
        :type delivery_end: datetime
        :param delivery_from: limit signals to those that have a delivery start greater or equal to the given value
        :type delivery_from: datetime
        :param delivery_to: limit signals to those that have a delivery end less than or equal to the given value
        :type delivery_to: datetime
        :param minutes_to_delivery_gte: The value of `minutes_to_delivery` which is greater than or equal to input parameter. Has to be used together with `minutes_to_delivery_lte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_gte: int
        :param minutes_to_delivery_lte: The value of `minutes_to_delivery` which is less than or equal to input parameter. Has to be used together with `minutes_to_delivery_gte` and cannot be combined with `active_only`.
        :type minutes_to_delivery_lte: int
        :param received_from: from timestamp is 'inclusive' (i.e. >=), use UTC timezone
        :type received_from: datetime
        :param received_to: to timestamp is 'exclusive' (i.e. <), use UTC timezone
        :type received_to: datetime
        :param revision_from: The starting revision from 0
        :type revision_from: int
        :param revision_to: The ending revision (non-inclusive)
        :type revision_to: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_durations_serialize(
            delivery_area=delivery_area,
            portfolio_id=portfolio_id,
            delivery_start=delivery_start,
            delivery_end=delivery_end,
            delivery_from=delivery_from,
            delivery_to=delivery_to,
            minutes_to_delivery_gte=minutes_to_delivery_gte,
            minutes_to_delivery_lte=minutes_to_delivery_lte,
            received_from=received_from,
            received_to=received_to,
            revision_from=revision_from,
            revision_to=revision_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SignalSourceDurations]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_sources_durations_serialize(
        self,
        delivery_area,
        portfolio_id,
        delivery_start,
        delivery_end,
        delivery_from,
        delivery_to,
        minutes_to_delivery_gte,
        minutes_to_delivery_lte,
        received_from,
        received_to,
        revision_from,
        revision_to,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if delivery_area is not None:
            
            _query_params.append(('delivery_area', delivery_area))
            
        if portfolio_id is not None:
            
            _query_params.append(('portfolio_id', portfolio_id))
            
        if delivery_start is not None:
            if isinstance(delivery_start, datetime):
                _query_params.append(
                    (
                        'delivery_start',
                        delivery_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_start', delivery_start))
            
        if delivery_end is not None:
            if isinstance(delivery_end, datetime):
                _query_params.append(
                    (
                        'delivery_end',
                        delivery_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_end', delivery_end))
            
        if delivery_from is not None:
            if isinstance(delivery_from, datetime):
                _query_params.append(
                    (
                        'delivery_from',
                        delivery_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_from', delivery_from))
            
        if delivery_to is not None:
            if isinstance(delivery_to, datetime):
                _query_params.append(
                    (
                        'delivery_to',
                        delivery_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('delivery_to', delivery_to))
            
        if minutes_to_delivery_gte is not None:
            
            _query_params.append(('minutes_to_delivery_gte', minutes_to_delivery_gte))
            
        if minutes_to_delivery_lte is not None:
            
            _query_params.append(('minutes_to_delivery_lte', minutes_to_delivery_lte))
            
        if received_from is not None:
            if isinstance(received_from, datetime):
                _query_params.append(
                    (
                        'received_from',
                        received_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_from', received_from))
            
        if received_to is not None:
            if isinstance(received_to, datetime):
                _query_params.append(
                    (
                        'received_to',
                        received_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('received_to', received_to))
            
        if revision_from is not None:
            
            _query_params.append(('revision_from', revision_from))
            
        if revision_to is not None:
            
            _query_params.append(('revision_to', revision_to))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/trading-signals/sources',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_trading_signals(
        self,
        signal_entry: Annotated[List[SignalEntry], Field(description="Signal payload")],
        ignore_lock: Annotated[Optional[StrictBool], Field(description="Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.")] = None,
        delete_related: Annotated[Optional[StrictBool], Field(description="Set this to `true`, if related slices, meaning slices with the same source, delivery area, portfolio ID and delivery period should be overridden and replaced by the newly sent items.")] = None,
        algorithm_id: Annotated[Optional[StrictStr], Field(description="The algorithm associated with the posted signals. When set, the parameters of the signals will be validated against the schema of the algorithm.")] = None,
        disable_history: Annotated[Optional[StrictBool], Field(description="Setting this value to true disables the persistence and historization feature for signals, meaning that only the latest revisions of updated signals will be stored. We strongly encourage you to enable this if you plan on submitting more than a few dozen revisions per signal source, as it improves performance of subsequent requests that use signals significantly.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignalEntryResponse:
        """Save trading signals

        This endpoint allows you to add or update trading signals. A trading signal can consist of multiple time slices, each with its individual validity period and set of parameters. The validity of a time slice is defined by an offset (in minutes) relative to the respective delivery start. For each trading signal only one time slice can be active at any given point in time. For a time slice to be considered active, the current time to delivery start must have passed the offset configuration. Moreover, only the time slice closest to the current time takes effect. For instance, suppose a trading signal has two time slices with their respective offsets set to 45 and 75 minutes relative to delivery start. Assuming that there are still 60 minutes until delivery start, then the active time slice would be one with an offset of 75 minutes. Eventually, as the time to delivery start passes the 45 minute mark the active time slice is switched.  Sending multiple time slices with the same offset is not allowed and will return an error message for each time slice affected. When sending multiple time slices, you can use the `delete_related` parameter to remove existing related time slices. Related time slices in this context are defined as those which have the same source, area, portfolio ID and delivery period. Only unlocked slices will be deleted when set. Updating the parameters of an existing time slice always completely override existing data.

        :param signal_entry: Signal payload (required)
        :type signal_entry: List[SignalEntry]
        :param ignore_lock: Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.
        :type ignore_lock: bool
        :param delete_related: Set this to `true`, if related slices, meaning slices with the same source, delivery area, portfolio ID and delivery period should be overridden and replaced by the newly sent items.
        :type delete_related: bool
        :param algorithm_id: The algorithm associated with the posted signals. When set, the parameters of the signals will be validated against the schema of the algorithm.
        :type algorithm_id: str
        :param disable_history: Setting this value to true disables the persistence and historization feature for signals, meaning that only the latest revisions of updated signals will be stored. We strongly encourage you to enable this if you plan on submitting more than a few dozen revisions per signal source, as it improves performance of subsequent requests that use signals significantly.
        :type disable_history: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_trading_signals_serialize(
            signal_entry=signal_entry,
            ignore_lock=ignore_lock,
            delete_related=delete_related,
            algorithm_id=algorithm_id,
            disable_history=disable_history,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignalEntryResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_trading_signals_with_http_info(
        self,
        signal_entry: Annotated[List[SignalEntry], Field(description="Signal payload")],
        ignore_lock: Annotated[Optional[StrictBool], Field(description="Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.")] = None,
        delete_related: Annotated[Optional[StrictBool], Field(description="Set this to `true`, if related slices, meaning slices with the same source, delivery area, portfolio ID and delivery period should be overridden and replaced by the newly sent items.")] = None,
        algorithm_id: Annotated[Optional[StrictStr], Field(description="The algorithm associated with the posted signals. When set, the parameters of the signals will be validated against the schema of the algorithm.")] = None,
        disable_history: Annotated[Optional[StrictBool], Field(description="Setting this value to true disables the persistence and historization feature for signals, meaning that only the latest revisions of updated signals will be stored. We strongly encourage you to enable this if you plan on submitting more than a few dozen revisions per signal source, as it improves performance of subsequent requests that use signals significantly.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignalEntryResponse]:
        """Save trading signals

        This endpoint allows you to add or update trading signals. A trading signal can consist of multiple time slices, each with its individual validity period and set of parameters. The validity of a time slice is defined by an offset (in minutes) relative to the respective delivery start. For each trading signal only one time slice can be active at any given point in time. For a time slice to be considered active, the current time to delivery start must have passed the offset configuration. Moreover, only the time slice closest to the current time takes effect. For instance, suppose a trading signal has two time slices with their respective offsets set to 45 and 75 minutes relative to delivery start. Assuming that there are still 60 minutes until delivery start, then the active time slice would be one with an offset of 75 minutes. Eventually, as the time to delivery start passes the 45 minute mark the active time slice is switched.  Sending multiple time slices with the same offset is not allowed and will return an error message for each time slice affected. When sending multiple time slices, you can use the `delete_related` parameter to remove existing related time slices. Related time slices in this context are defined as those which have the same source, area, portfolio ID and delivery period. Only unlocked slices will be deleted when set. Updating the parameters of an existing time slice always completely override existing data.

        :param signal_entry: Signal payload (required)
        :type signal_entry: List[SignalEntry]
        :param ignore_lock: Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.
        :type ignore_lock: bool
        :param delete_related: Set this to `true`, if related slices, meaning slices with the same source, delivery area, portfolio ID and delivery period should be overridden and replaced by the newly sent items.
        :type delete_related: bool
        :param algorithm_id: The algorithm associated with the posted signals. When set, the parameters of the signals will be validated against the schema of the algorithm.
        :type algorithm_id: str
        :param disable_history: Setting this value to true disables the persistence and historization feature for signals, meaning that only the latest revisions of updated signals will be stored. We strongly encourage you to enable this if you plan on submitting more than a few dozen revisions per signal source, as it improves performance of subsequent requests that use signals significantly.
        :type disable_history: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_trading_signals_serialize(
            signal_entry=signal_entry,
            ignore_lock=ignore_lock,
            delete_related=delete_related,
            algorithm_id=algorithm_id,
            disable_history=disable_history,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignalEntryResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_trading_signals_without_preload_content(
        self,
        signal_entry: Annotated[List[SignalEntry], Field(description="Signal payload")],
        ignore_lock: Annotated[Optional[StrictBool], Field(description="Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.")] = None,
        delete_related: Annotated[Optional[StrictBool], Field(description="Set this to `true`, if related slices, meaning slices with the same source, delivery area, portfolio ID and delivery period should be overridden and replaced by the newly sent items.")] = None,
        algorithm_id: Annotated[Optional[StrictStr], Field(description="The algorithm associated with the posted signals. When set, the parameters of the signals will be validated against the schema of the algorithm.")] = None,
        disable_history: Annotated[Optional[StrictBool], Field(description="Setting this value to true disables the persistence and historization feature for signals, meaning that only the latest revisions of updated signals will be stored. We strongly encourage you to enable this if you plan on submitting more than a few dozen revisions per signal source, as it improves performance of subsequent requests that use signals significantly.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Save trading signals

        This endpoint allows you to add or update trading signals. A trading signal can consist of multiple time slices, each with its individual validity period and set of parameters. The validity of a time slice is defined by an offset (in minutes) relative to the respective delivery start. For each trading signal only one time slice can be active at any given point in time. For a time slice to be considered active, the current time to delivery start must have passed the offset configuration. Moreover, only the time slice closest to the current time takes effect. For instance, suppose a trading signal has two time slices with their respective offsets set to 45 and 75 minutes relative to delivery start. Assuming that there are still 60 minutes until delivery start, then the active time slice would be one with an offset of 75 minutes. Eventually, as the time to delivery start passes the 45 minute mark the active time slice is switched.  Sending multiple time slices with the same offset is not allowed and will return an error message for each time slice affected. When sending multiple time slices, you can use the `delete_related` parameter to remove existing related time slices. Related time slices in this context are defined as those which have the same source, area, portfolio ID and delivery period. Only unlocked slices will be deleted when set. Updating the parameters of an existing time slice always completely override existing data.

        :param signal_entry: Signal payload (required)
        :type signal_entry: List[SignalEntry]
        :param ignore_lock: Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.
        :type ignore_lock: bool
        :param delete_related: Set this to `true`, if related slices, meaning slices with the same source, delivery area, portfolio ID and delivery period should be overridden and replaced by the newly sent items.
        :type delete_related: bool
        :param algorithm_id: The algorithm associated with the posted signals. When set, the parameters of the signals will be validated against the schema of the algorithm.
        :type algorithm_id: str
        :param disable_history: Setting this value to true disables the persistence and historization feature for signals, meaning that only the latest revisions of updated signals will be stored. We strongly encourage you to enable this if you plan on submitting more than a few dozen revisions per signal source, as it improves performance of subsequent requests that use signals significantly.
        :type disable_history: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_trading_signals_serialize(
            signal_entry=signal_entry,
            ignore_lock=ignore_lock,
            delete_related=delete_related,
            algorithm_id=algorithm_id,
            disable_history=disable_history,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignalEntryResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_trading_signals_serialize(
        self,
        signal_entry,
        ignore_lock,
        delete_related,
        algorithm_id,
        disable_history,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'SignalEntry': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ignore_lock is not None:
            
            _query_params.append(('ignore_lock', ignore_lock))
            
        if delete_related is not None:
            
            _query_params.append(('delete_related', delete_related))
            
        if algorithm_id is not None:
            
            _query_params.append(('algorithm_id', algorithm_id))
            
        if disable_history is not None:
            
            _query_params.append(('disable_history', disable_history))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if signal_entry is not None:
            _body_params = signal_entry


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/trading-signals',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_signals(
        self,
        value: Annotated[List[BulkSignal], Field(description="Signals payload")],
        ignore_lock: Annotated[Optional[StrictBool], Field(description="Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BulkSignalResponse]:
        """(Deprecated) Add signals

        DEPRECATED. Signals are replaced by Trading Signals. Any request to this endpoint will also add a trading signal with a offset from now until delivery start. Allows you to send trading signals to the system, e.g. positions, fundamental data, weather data or outputs of an optimization software. This data is then aligned to contracts at the market and delivered with the orderbook. This way, trading signals are automatically archived for ex-post analysis and algorithms do not need to import data themselves. In addition, signals are displayed in the dashboard.  This methods can receive a collection of signals at once and each signal has a freely defined source (e.g. ETRM_system).  Note that it is not possible to post signals for a defined contract. All contracts which have the specified \"delivery_start\" and \"delivery_end\" field will receive the signal (e.g. XBID and local contracts), limited to the specified delivery areas and portfolios.  A signal can contain EITHER a position_long and position_short (the MWs to be traded, both need to be equal or greater than zero) OR a freely defined JSON object containing key/value pairs, but not both at once.  **Heads up** The \"source\" of a signal containing position_long and position_short will always be \"POSITION\", no matter what is defined in the request body.  * \"position_long\" indicates the surplus in MW that should or can be sold at the market (equal or greater than zero)  * \"position_short\" indicates the deficiency in MW that should or can be bought at the market (equal or greater than zero)  * \"value\" should contain the freely defined JSON object with key/value pairs. Please be aware that a signal-key for each contract is unique and data is overwritten, if sent from multiple sources.

        :param value: Signals payload (required)
        :type value: List[BulkSignal]
        :param ignore_lock: Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.
        :type ignore_lock: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /signals is deprecated.", DeprecationWarning)

        _param = self._update_signals_serialize(
            value=value,
            ignore_lock=ignore_lock,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BulkSignalResponse]",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_signals_with_http_info(
        self,
        value: Annotated[List[BulkSignal], Field(description="Signals payload")],
        ignore_lock: Annotated[Optional[StrictBool], Field(description="Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BulkSignalResponse]]:
        """(Deprecated) Add signals

        DEPRECATED. Signals are replaced by Trading Signals. Any request to this endpoint will also add a trading signal with a offset from now until delivery start. Allows you to send trading signals to the system, e.g. positions, fundamental data, weather data or outputs of an optimization software. This data is then aligned to contracts at the market and delivered with the orderbook. This way, trading signals are automatically archived for ex-post analysis and algorithms do not need to import data themselves. In addition, signals are displayed in the dashboard.  This methods can receive a collection of signals at once and each signal has a freely defined source (e.g. ETRM_system).  Note that it is not possible to post signals for a defined contract. All contracts which have the specified \"delivery_start\" and \"delivery_end\" field will receive the signal (e.g. XBID and local contracts), limited to the specified delivery areas and portfolios.  A signal can contain EITHER a position_long and position_short (the MWs to be traded, both need to be equal or greater than zero) OR a freely defined JSON object containing key/value pairs, but not both at once.  **Heads up** The \"source\" of a signal containing position_long and position_short will always be \"POSITION\", no matter what is defined in the request body.  * \"position_long\" indicates the surplus in MW that should or can be sold at the market (equal or greater than zero)  * \"position_short\" indicates the deficiency in MW that should or can be bought at the market (equal or greater than zero)  * \"value\" should contain the freely defined JSON object with key/value pairs. Please be aware that a signal-key for each contract is unique and data is overwritten, if sent from multiple sources.

        :param value: Signals payload (required)
        :type value: List[BulkSignal]
        :param ignore_lock: Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.
        :type ignore_lock: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /signals is deprecated.", DeprecationWarning)

        _param = self._update_signals_serialize(
            value=value,
            ignore_lock=ignore_lock,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BulkSignalResponse]",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_signals_without_preload_content(
        self,
        value: Annotated[List[BulkSignal], Field(description="Signals payload")],
        ignore_lock: Annotated[Optional[StrictBool], Field(description="Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Add signals

        DEPRECATED. Signals are replaced by Trading Signals. Any request to this endpoint will also add a trading signal with a offset from now until delivery start. Allows you to send trading signals to the system, e.g. positions, fundamental data, weather data or outputs of an optimization software. This data is then aligned to contracts at the market and delivered with the orderbook. This way, trading signals are automatically archived for ex-post analysis and algorithms do not need to import data themselves. In addition, signals are displayed in the dashboard.  This methods can receive a collection of signals at once and each signal has a freely defined source (e.g. ETRM_system).  Note that it is not possible to post signals for a defined contract. All contracts which have the specified \"delivery_start\" and \"delivery_end\" field will receive the signal (e.g. XBID and local contracts), limited to the specified delivery areas and portfolios.  A signal can contain EITHER a position_long and position_short (the MWs to be traded, both need to be equal or greater than zero) OR a freely defined JSON object containing key/value pairs, but not both at once.  **Heads up** The \"source\" of a signal containing position_long and position_short will always be \"POSITION\", no matter what is defined in the request body.  * \"position_long\" indicates the surplus in MW that should or can be sold at the market (equal or greater than zero)  * \"position_short\" indicates the deficiency in MW that should or can be bought at the market (equal or greater than zero)  * \"value\" should contain the freely defined JSON object with key/value pairs. Please be aware that a signal-key for each contract is unique and data is overwritten, if sent from multiple sources.

        :param value: Signals payload (required)
        :type value: List[BulkSignal]
        :param ignore_lock: Setting this parameter to true allows for modification of locked signals. Unlocking a signal also requires this parameter to be true.
        :type ignore_lock: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /signals is deprecated.", DeprecationWarning)

        _param = self._update_signals_serialize(
            value=value,
            ignore_lock=ignore_lock,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BulkSignalResponse]",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_signals_serialize(
        self,
        value,
        ignore_lock,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'value': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ignore_lock is not None:
            
            _query_params.append(('ignore_lock', ignore_lock))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if value is not None:
            _body_params = value


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key_security'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/signals',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


